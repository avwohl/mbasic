MBASIC VT180, VS.21
BASIC-80 REFERENCE MANUAL
AA-P226A-TV

MBASIC VT180, VS.21
BASIC-80 REFERENCE MANUAL
AA-P226A-TV

developed by
MICROSOFT CORPORATION
Bellevue, Washing ton

DIGITAL EQUIPMENT CORPORATION
Maynard, Massachusetts

The information in this document is subject to change
without notice and should not be construed as a commitment by Digital Equipment Corporation. Digital
Equipment Corporation assumes no responsibility for any
errors that may appear in this document.
The software described in this document is furnished
under a license and may only be used or copied in
accordance with the terms of such license.
No responsibility is assumed for the use or reliability
of software by DIGITAL or its affiliated companies.
Copyright

G

1979, MICROSOFT CORPORATION

Licensed to DIGITAL EQUIPMENT CORPORATION,
Maynard, Massachusetts.

The following are trademarks of Digital Equipment
Corporation:
ASSIST
COMPUTER LABS
COMTEX
DATATRIEVE
DDT
DEC
DECCOMM
DECmate
DECnet
DECSYSTEM-IO
DECSYSTEM-20
DECtape
DECUS
DECwriter
DIBOL

DIGITAL
EDUsystem
FLIP CHIP
FOCAL
lAS
INDAC
ITPS-IO
LAB-8
MASSBUS
OMNIBUS
OS/8
PDP
PDT
PHA

RSTS
RSX
RTS-8
SBI
TMS-II
TRAX .
TYPESET-8
TYPESET-II
UNIBUS
VAX
VMS
VT
Work Processor
VTl80

CP/M is a trademark of Digital Research

PRODUCT EXCEPTION REPORTING SERVICE:
If, prior to SEPTEMBER 1, 1983, the customer encounters a problem
wi th the software. as orig inally furnished
a Product Exception
Report may be sub~itted to:
Digital Equipment Corporation
BOX A
146 Main Street
Maynard, MA 01754
Throug h the software authors, DIGITAL wi 11, wi thout add i tional
charg e, respond to the reported error in the current unaltered
release of the software by issuing any known correction information to the customer reporting the problem and/or issuing notice
of the availability of corrected code. However, DIGITAL makes no
representations or guarantees that such a response will be forthcoming and DIGITAL assumes no responsibility or liability for
such a response or the accuracy thereof.
WARRANTY:
NONE.

THIS SOFTWARE PRODUCT IS PROVIDED "AS IS".

APPLICATION SOFTWARE LIBRARY
IDmDomo EXTERNAL
PRODUCT EXCEPTION REPORT (PER)

PAGE

_EASE TYPE

ROGRAM OR DOCUMENT TITLE

10PERATING SYSTEM

lOA NUMBER

AN THE PROBLEM BE REPRODUCED AT WILL?

YES

0

PU TYPE \MEMORY SIZE IDISTRIBUTION MEDIUM \SYS DEVICE
I

NO

OF

--

I

IVERSION

--

DATE

0

I

ATTACHMENTS

IMAGTAPE

0

FLOPPY DISKS

0

LISTING

0

DECTAPE II

ALL SUBMISSIONS BECOME THE PROPERTY OF DIGITAL EQUIPMENT CORPORATION

Mail To:

NAME:

Digital Equipment Corporation

FIRM:

Box A 146 Main Street
Maynard, MA 01754

ADDRESS:
CUST. NO:
U!3MITTED BY:

lATE RECEIVED (MAIL)

I-01613-07-0000(3E9)

PHONE:

\ DATE TO AUTHOR

"If received prior to the PER expiration date of the product, Digital will,
thru the product author(s). respond to a reported error in the current
unaltered release of the software by issuing any known correction
information to the customer reporting the problem and/or issuing
notice of the availability of corrected code. However, Digital makes no
representations or guarantees that such a response will be forthcoming
and Digital assumes no responsibility or liability for such a response
or the accuracy thereof. Except as specified in this paragraph, Digital
does not support or maintain the software."
\ DATE RECEIVED FROM AUTHOR

\ DATE ANSWERED

0

basic-80
reference
manual

This manual is a reference for Microsoft's BASIC-80 language, release 5.0 and later.
There are significant differences between the 5.0 release of BASIC-80 and the previous releases
(release 4.51 and earlier). If you have programs written under a previous release of BASIC-80,
check Appendix A for new features in 5.0 that may affect execution.

Information in this document is subject to change without notice and does not represent a
commitment on the part of Microsoft. The software described in this document is
furnished under a license agreement or non-disclosure agreement. The software may be
used or copied only in accordance with the terms of the agreement.

(C) Microsoft, 1979

8101-520-06

BASIC-80 Reference Manual
CONTENTS

PAGE

INTRODUCTION
CHAPTER 1

General Information about BASIC-80

1-1

CHAPTER 2

BASIC-80 Commands and Statements

2-1

CHAPTER 3

BASIC-80 Functions

3-1

APPENDIX A

New Features in BASIC-80. Release 5.0

A-I

APPENDIX B

BASIC-80 Disk I/O

B-1

APPENDIX C

Assembly Language Subroutines

C-l

APPENDIX D

BASIC-80 with the CP/M Operating System

D-l

APPENDIX E

Converting Programs to BASIC-80

E-l

APPENDIX F

Summary of Error Codes and Error Messages

F-l

APPENDIX G

Mathematical Functions

G-l

APPENDIX H

ASCII Character Codes

H-l

INDEX

I-I

Introduction

BASIC-80 is the most extensive implementation of BASIC
available for the 8080 and Z80 microprocessors.
In its
fifth major release (Release 5.0), BASIC-80 meets the ANSI
qualifications
for
BASIC,
as set forth in document
BSRX3.60-1978. Each release of BASIC-80 consists of three
upward compatible versions:
8K, Extended and Disk. This
manual is a reference for all three versions of BASIC-80,
release 5.0 and later. This manual is also a reference for
Microsoft BASIC-86 and the Microsoft
BASIC
Compiler.
BASIC-86
is currently available in Extended and Disk
Standalone versions, which are comparable to the BASIC-80
Extended and Disk Standalone versions.
There are significant differences between the 5.0 release of
BASIC-80
and the previous releases (release 4.51 and
earlier). If you have programs written under a previous
release of BASIC-80, check Appendix A for new features in
5.0 that may affect execution.
The manual is divided into three large chapters plus a
number of appendices. Chapter 1 covers a variety of topics,
largely pertaining to information representation when using
BASIC-80.
Chapter 2 contains the syntax and semantics of
every
command
and
statement
in
BASIC-80,
ordered
alphabetically.
Chapter 3 describes all of BASIC-80~s
intrinsic functions, also ordered alphabetically.
The
appendices contain information pertaining to individual
operating systems: plus lists of error messages, ASCII
codes, and math functions:
and helpful information on
assembly language subroutines and disk I/O.

Page 1-1

CHAPTER 1
GENERAL INFORMATION ABOUT BASIC-SO

1.1

INITIALIZATION

The procedure for initialization will vary with different
implementations of BASIC-SO. Check the appropriate appendix
at the back of this manual to determine how BASIC-SO is
initialized with your operating system.

1.2

MODES OF OPERATION

When BASIC-SO is initialized, it types the prompt "Ok".
"Ok" means BASIC-SO is at command level, that is, it is
ready to accept commands. At this point, BASIC-SO may be
used in either of two modes:
the direct mode or the
indirect mode.
In the direct mode, BASIC statements and commands are not
preceded by line numbers.
They are executed as they are
entered. Results of arithmetic and logical operations may
be displayed immediately and stored for later use, but the
instructions themselves are lost after execution. This mode
is
useful
for
debugging and for using BASIC as a
"calculator" for quick computations that do not require a
complete program.
The indirect mode is the mode used for entering programs.
Program lines are preceded by line numbers and are stored in
memory.
The program stored in memory is executed by
entering the RUN command.

1.3

LINE FORMAT

Program lines in a BASIC program have the
(square brackets indicate optional) :

following

format

nnnnn BASIC statement[:BASIC statement .•. ] <carriage return>

GENERAL INFORMATION ABOUT BASIC-80

Page 1-2

At the proqrammer"'s option, more than one BASIC statement
may be placed on a line, but each statement on a line must
be separated from the last by a colon.
A BASIC program line always begins with a line number,
with a carriage return, and may contain a maximum of:

ends

72 characters in 8K BASIC-80
255 characters in Extended and Disk BASIC-80.
In Extended and Disk versions, it is possible to extend a
logical line over more than one physical line by use of the
terminal"'s <line feed> key. <Line feed> lets you continue
typing a logical line on the next physical line without
entering a <carriage return>. (In the 8K version, <line
feed> has no effect.)

1.3.1

Line Numbers

Every BASIC program line begins with a line number.
Line
numbers indicate the order in which the program lines are
stored in memory and are' also used as references when
branching and editing. Line numbers must be in the range a
to 65529. In the Extendedi and Disk versions, a per iod (.)
may be used in EDIT, LIST, AUTO and DELETE commands to refer
to the current line.

GENERAL INFORMATION ABOUT BASIC-SO
1.4

Page 1-3

CHARACTER SET

The BASIC-SO character set is comprised of alphabetic
characters, numeric characters and special characters.
The alphabetic characters in BASIC-SO are the upper case and
lower case letters of the alphabet.
The numeric characters in BASIC-SO are the digits 0
9.
The following special characters
recognized by BASIC-SO:
Character
=

+

*

/,.
(
)

%

i
$
[
]

,

.
~

&

?

<
>

\
@

<rubout>
<escape>
<tab>
<line feed>
<carriage
return>

and

terminal

through
keys

-Name
Blank
Equal sign or assignment symbol
Plus sign
Minus sign
Asterisk or multiplication symbol
Slash or division symbol
Up arrow or exponentiation symbol
Left parenthesis
Right parenthesis
Percent
Number (or pound) sign
Dollar sign
Exclamation point
Left bracket
Right bracket
Comma
Period or decimal point
Single quotation mark (apostrophe)
Semicolon
Colon
Ampersand
Question mark
Less than
Greater than
Backs1ash or integer division symbol
At-sign
Underscore
Deletes last character typed.
Escapes Edit Mode subcommands.
See Section 2.16.
Moves print position to next tab stop.
Tab stops are every eight columns.
Moves to next, physical line.
Terminates input of a line.

are

GENERAL INFORMATION ABOUT BASIC-80
1.4.1

Page 1-4

Control Characters

The following control characters are in BASIC-80:
Contro1-A

Enters Edit Mode on the line being typed.

Contro1-C

Interrupts program execution
BASIC-80 command level.

Contro1-G

Rings the bell at the terminal.

Contro1-B

Backspace.

Contro1-I

Tab.

Contro1-0

Ba1ts
program
continues.
A
output.

Contro1-R

Retypes
typed.

Contro1-S

Suspends program execution.

Contro1-Q

Resumes program execution after a Contro1-S.

Contro1-U

Deletes
typed.

1.5

and

returns

to

Deletes the last character typed.

Tab stops are every eight columns.

the

the

line

line

output
second
that

that

while
execution
Contro1-0 restarts
is

is

currently

currently

being

being

CONSTANTS

Constants are the actual values BASIC uses during execution.
There are two types of constants: string and numeric.
A string constant is a sequence of up to 255 alphanumeric
characters enclosed in double quotation marks. Examples of
string constants:
"HELLO"
"$25,000.00"
"Number of Employees"
Numeric constants are positive or negative numbers. Numeric
constants in BASIC cannot contain commas. There are five
types of numeric constants:
1.

Integer constants

Whole numbers between -32768 and
+32767.
Integer constants do not
have decimal points.

2.

Fixed Point
constants

Positive or negative real numbers,
i.e., numbers that contain decimal
points.

GENERAL INFORMATION ABOUT BASIC-80
3.

Floating Point
constants

Page 1-5

Positive or negative numbers represented in exponential form (similar
to
scientific
notation).
A
floating point constant consists of
an optionally signed integer or
fixed point number
(the mantissa)
followed by the letter E and an
optionally signed
integer
(the
exponent). The allowable range for
floating point constants is, 10-38
to 10+38.
Examples:
235.988E-7 = .0000235988
2359E6 = 2359000000
(Double preclslon floating point
constants use the letter D instead
of E. See Section 1.5.1.)

4.

Hex constants

Hexadecimal numbers with the prefix
&H. Examples:
&H76
&H32F

5.

Octal constants

Octal numbers with the prefix &0 or
Examples:

Se.

&0347
&1234

1.5.1

Single And Double Precision ~ !££ Numeric Constants

In the 8K version of BASIC-80, all numeric constants are
single precision numbers. They are stored with 7 digits of
precision, and printed with up to 6 digits.

\

however, \ numeric
In the Extended and Disk versions,
constants may be either single precision or double precision
numbers. with double precision, the numbers are stored with
16 digits of precision, and printed with up to 16 digits.

GENERAL INFORMATION ABOUT BASIC-80
A single precision constant is
has:

Page 1-6

any

numeric

1.

seven or fewer digits, or

2.

exponential form using E, or

3.

a trailing exclamation point

A double precision constant is
has:

any

eight or more digits, or

2.

exponential form using 0, or

3.

a trailing number sign (#)

that

constant

that

(1)

numeric

1.

constant

Examples:
Single Precision Constants
46.8
-1.09E-06
3489.0
22.5!

1. 6

Double Precision Constants
345692811
-1.09432D-06
3489.0#
7654321.1234

VARIABLES

Variables are names used to represent values that are used
in a BASIC program. The value of a variable may be assigned
explicitly by the programmer, or it may be assigned as the
result of calculations in the program. Before a variable is
assigned a value, its value is assumed to be zero.

1.6.1

Variable Names And Declaration Characters

BASIC-80 variable names may be any length, however, in the
8K version, only the first two characters are significant.
In the Extended and Disk versions, up to 40 characters are
significant.
The characters allowed in a variable name are
letters and numbers, and the decimal point is allowed in
Extended and Disk variable names. The first character must
be a letter. Special type declaration characters are also
allowed -- see below.
A variable name may not be a reserved word.
The Extended
and Disk versions allow embedded reserved words; the 8K
version does not. If a variable begins with FN, it is
assumed to be a call to a user-defined function. Reserved
words include all BASIC-80 commands, statements, function

Page 1-7

GENERAL INFORMATION ABOUT BASIC-80
names and operator names.

Variables may represent either a numeric value or a string.
String variable names are written with a dollar sign ($) as
the last character. For example: A$ = "SALES REPORT". The
dollar sign is a variable type declaration character, that
is, it "declares" that the variable will represent a string.
In the Extended and Disk versions, numeric variable names
may declare integer, single or double precision values.
(All numeric values in 8K are single precision.) The type
declaration characters for these variable names are as
follows:
%

Integer variable
Single precision variable

*

Double precision variable

The default type for
precision.

a

numeric

variable

name

is

single

Examples of BASIC-80 variable names follow.
In Extended and Disk versions:
PIt
MINIMUM!
LIMIT%

declares a double precision value
declares a single precision value
declares an integer value

In 8K, Extended and Disk versions:
N$
ABC

declares a string value
represents a single precision value

In the Extended and Disk versions of BASIC-80, there is a
second method by which variable types may be declared. The
BASIC-80 statements DEFINT, DEFSTR, DEFSNG and DEFDBL may be
included in a program to declare the types for certain
variable names. These statements are described in detail in
Section 2.12.

1.6.2

Array Variables

An array is a group or table of values referenced by the
same variable name. Each element in an array is referenced
by an array variable that is subscripted with an integer or
an integer expression. An array variable name has as many
subscripts as there are dimensions in the array.
For
example V(lO} would reference a value in a one-dimension
array, T(1,4) would reference a value in a two-dimension
array, and so on. The maximum number of dimensions for an

GENERAL INFORMATION ABOUT BASIC-80

Page 1-8

array is 255.
is 32767.

dimension

1.7

The maximum number of elements per

TYPE CONVERSION

When necessary, BASIC will convert a numeric constant from
one type to another.
The following rules and examples
should be kept in mind.
1.

If a numeric constant of one type is set equal to a
numeric variable of a different type, the number
will be stored as the type declared in the variable
name.
(If a str ing var iable is set equal to a
numeric value or vice versa, a "Type mismatch"
error occurs.)
Example:
10 A% = 23.42
20 PRINT A%
RUN
23

2.

During expression evaluation, all of the operands
in
an arithmetic or relational operation are
converted to the sane degree of precision, i.e.,
that of the most precise operand. Also, the result
of an arithmetic operation is returned to this
degree of precision.
Examples:
10 D* = 6*/7
The arithmetic was performed
20 PRINT D*
in double precision and the
RUN
result was returned in D*
.8571428571428571 as a double precision value.
10 D = 6*/7
20 PRINT D
RUN
.857143

3.

The arithmetic was performed
in double precision and the
result was returned to D (single
precision variable), rounded and
printed as a single precision
value.

Logical operators (see Section 1.8.3) convert their
operands to integers and return an integer result.
Operands must be in the range -32768 to 32767 or an
"Overflow" error occurs.

GENERAL INFORMATION ABOUT BASIC-SO
4.

When a floating point value is converted
integer, the fractional portion is rounded.
Example:

Page 1-9
to

an

10 C% = 55.SS
20 PRINT C%
RUN
56
5.

If a double prec1s1on variable is assigned a single
prec1s10n value, only the first seven digits,
rounded, of the converted number will be valid.
This is because only seven digits of accuracy were
supplied with the single precision value.
The
absolute
value of the difference between the
printed double precision number and the original
single precision value will be less than 6.3E-S
times the original single precision value.
Example:
10 A = 2.04
20 Bi
A
30 PRINT A;Bi
RUN
2.04 2.03999996lS53027

=

1.S

EXPRESSIONS AND OPERATORS

An expression may be simply a string or numeric constant, or
a variable, or it may combine constants and variables with
operators to produce a single value.
Operators perform mathematical or logical operations on
values.
The operators provided by BASIC-SO may be divided
into four categories:
1.

Arithmetic

2.

Relational

3.

Logical

4.

Functional

GENERAL INFORMATION ABOUT BASIC-80
1.8.1

Page 1-10

Arithmetic Operators

The arithmetic operators, in order of precedence, are:
Operator

Operation

*,/
+,-

Sample Expression

Exponentiation

X"Y

Negation

-x

Multiplication, Floating
Point Division

x*y

Addition, Subtraction

X+y

X/y

To change the order in which the operations are performed,
use
parentheses.
Operations
within
parentheses are
performed first. Inside parentheses, the usual order of
operations is maintained.
Here are some sample algebraic expressions and
counterparts.
Algebraic Expression

X+Y*2

Y
Z

X-y/z

Z-

XY

X*y/z

-z

X+Y

(X+Y)/Z

(X2) y
yZ

(X"2)"Y

X

X(-Y)

BASIC

BASIC Expression

X+2Y
X--

their

X" (y" Z)

X*(-Y) Two consecutive
operators must
be separated by
parentheses.

1.8.1.1 Integer Division And Modulus Arithmetic Two additional operators are-available in Extended and Disk
versions
of
BASIC-80:
Integer division and modulus
arithmetic.
The
Integer division is denoted by the baskslash (\).
operands are rounded to integers (must be in the range
-32768 to 32767) before the division is performed, and the
quotient is truncated to an integer.

GENERAL INFORMATION ABOUT BASIC-80

Page 1-11

For example:
10\4 = 2
25.68\6.99 = 3
The precedence of
integer
division
is
multiplication and floating point division.

just

after

Modulus arithmetic is denoted by the operator MOD.
It gives
the integer value that is the remainder of an integer
division. For example:
10.4 MOD 4 = 2 (10/4=2 with a remainder 2)
25.68 MOD 6.99 = 5 (26/7=3 with a remainder 5)
The precedence of modulus arithmetic is just
division.

after

integer

1.8.1.2 Overflow And Division ~ Zero If, during the evaluation of an expression, a division by
zero is encountered, the "Division by zero" error message is
displayed, machine infinity with the sign of the numerator
is supplied as the result of the division, and execution
continues.
If the evaluation of an exponentiation results
in zero being raised to a negative power, the "Division by
zero" error message is displayed, positive machine infinity
is supplied as the result of the exponentiation, and
execution continues.
If overflow occurs, the "Overflow" error
message
is
displayed, machine infinity with the algebraically correct
sign is supplied as the result, and execution continues.

1.8.2

Relational Operators

Relational operators are used to compare two values.
The
result of the comparison is .either "true" (-1) or "false"
(0). This result may then used to make a decision regarding
program flow.
(See IF, Section 2.26.)

GENERAL INFORMATION ABOUT BASIC-80

Page 1-12

Relation Tested

ExEression

=

Equality

X=Y

<>

Inequality

X<>Y

<

Less than

X<Y

>

Greater than

X>Y

<=

Less than or equal to

X<=Y

>=

Greater than or equal to

X>=Y

(The equal sign is also used to
variable. See LET, Section 2.30.)

assign

°Eerator

a

value

to

a

When arithmet.ic and relational operators are combined in one
expression, the ari,thmetic is always performed first. For
example, the expression
X+Y < (T-l)/Z
is-true if the value of X plus Y is less than the
T-l divided by Z. More examples:

value

of

IF SIN(X)<O GOTO 1000
IF I MOD J <> 0 THEN K=K+l

1.8.3

Logical 0Eerators

Logical operators perform tests on multiple relations, bit
manipulation, or Boolean operations. The logical operator
returns a bitwise result which is either "true" (not zero)
or "false" (zero). 'In an expression, logical operations are
performed after arithmetic and relational operations.
The
outcome of a logical operation is determined as shown in the
following table. The operators are listed in order of
precedence.

GENERAL INFORMATION ABOUT BASIC-80

Page 1-13

NOT
X

NOT X

a

1

a

1

AND
X

y

1

1

1

1

a

a

1

X

Y
1

a

X AND Y

a
o
a

a

OR
1
1

o
a

o
1

a

X

OR Y
1
1
1

o

XOR
X

1
1

Y
1

X XOR Y

a

o
a

o
1
a

1
1

X

Y

X IMP Y

1
1

1

1

a

1

a

1
1

X

y
1

X EQV Y
1

1

o

a

IMP

o

EQV
1
1

a

a

a

o
o

o

o

1

Just as the relational operators can be used to make
decisions regarding program flow,
logical operators can
connect two or more relations and return a true or false
value to be used in a decision (see IF, Section 2.26). For
example:
IF D<200 AND F<4 THEN 80
IF I>10 OR K<O THEN 50
IF NOT P THEN 100
Logical operators work by converting their operands to
sixteen bit, signed, two~scomplement integers in the range
-32768 to +32767.
(If the operands are not in this range,
an error results.) If both operands are supplied as a or -1,
logical operators return a or -1. The given operation is

GENERAL INFORMATION ABOUT BASIC-SO

Page 1-14

performed on these integers in bitwise fashion, i.e., each
bit of the result is determined by the corresponding bits in
the two ope rands '.
Thus, it is possible to use logical operators to test bytes
for a particular bit pattern.
For instance, the AND
operator may be used to "mask" all but one of the bits of a
status byte at a machine I/O port. The OR operator may be
used to "merge" two bytes to create a particular 'binary
value. The following examples will help demonstrate how the
logical operators work.
63 AND 16=16

63 = binary 111111 and 16 = binary
10000, so 63 AND 16 = 16

15 AND 14=14

15 = binary 1111 and 14 = binary 1110,
so 15 AND 14 = 14 (binary 1110)

-1 AND S=S

-1 = binary 1111111111111111 and
S = binary 1000, so -1 AND S = S

4 OR 2=6

4 = binary 100 and 2 = binary 10,
so 4 OR 2 = 6 (binary 110)

10 OR 10=10

10 = binary 1010, so 1010 OR 1010 =
1010 (10)

-lOR -2=-1

-1 = binary 1111111111111111 and
-2 = binary 1111111111111110,
so -lOR -2 = -1. The bit
complement of sixteen zeros is
sixteen ones, which is the
two~s complement represen,tation of -1.

NOT X=- (X+1)

The two~s complement of any integer
is the bit complement plus one.

1.S.4

Functional Operators

A function is used in an expression to call a predetermined
operation that is to be performed on an operand. BASIC-SO
has "intrinsic" functions that reside in the system, such as
SQR
(square root) or SIN (sine).
All of BASIC-SO"'s
intrinsic functions are described in Chapter 3 •
BASIC-SO also allows• "user defined" functions that are
written by the programmer. See DEF FN, Section 2.11.

GENERAL INFORMATION ABOUT BASIC-SO
1.S.5

Page 1-15

String Operations

Strings may be concatenated using +.

For example:

10 A$="FILE" : B$="NAME"
20 PRINT A$ + B$
30 PRINT "NEW " + A$ + B$
R~

FILENAME
NEW FILENAME
Strings may be compared using the same relational
that are used with numbers:

=

<>

<

>

<=

oper~tors

>=

String comparisons are made by taking one character at a
time from each string and comparing the ASCII codes. If all
the ASCII codes are the same, the strings are equal. If the
ASCII codes differ, the lower code number precedes the
higher. If, during string comparison, the end of one string
is reached, the shorter string is said to be smaller.
Leading and trailing blanks are significant. Examples:

"AA" < "AB"
"FILENAME" = "FILENAME"
"X&" > "Xi"
"CL " > "CL"
"kg" > "KG"
"SMYTH" < "SMYTHE"
B$ < "9/l2/7S"
where B$ = "S/12/7S"
Thus, string comparisons can be used to test string values
or to alphabetize strings.
All string constants used in
comparison expressions must be enclosed in quotation marks.

1.9

INPUT EDITING

If an incorrect. character is entered as a line is being
typed, it can be deleted with the RUBOUT key or with
Control-H. Rubout surrounds the deleted character(s) with
backslashes, and Contro1-H has the effect of backspacing
over a character and erasing it. Once a character(s) has
been deleted, simply continue typing the line as desired.
To delete a line that is in the process of being typed, type
Control-U.
A carriage return is executed automatically
after the line is deleted.
To correct program lines for a program that is currently in
memory, simply retype the line using the same line number.
BASIC-SO will automatically replace the old line with the
new line.

GENERAL INFORMATION ABOUT BASIC-SO

Page 1-16

More sophisticated editing capabilities are provided in the
Extended and Disk versions of BASIC-SO. See EDIT, Section
2.16.
To delete the entire program that is currently residing in
memory, enter the NEW command. (See Section 2.41.) NEW is
usually used to clear memory prior to entering a new
program.

1.10

ERROR MESSAGES

If BASIC-SO detects an error that causes program execution
to terminate, an error message is printed.
In the SK
version, only the error code is printed.
In the Extended
and Disk versions, the entire error message is printed. For
a complete list of BASIC-SO error codes and error messages,
see Appendix

Page 2-1

CHAPTER 2
BASIC-SO COMMANDS AND STATEMENTS

All of the BASIC-SO commands and statements are described in
this chapter. Each description is formatted as follows:
Format:

Shows the correct format for the instruction.
See below for format notation.

Versions:

Lists the. versions of BASIC-SO
in which the instruction is available.

Purpose:

Tells what the instruction is used for.

Remarks:

Describes in detail how the instruction
is used.

Example:

Shows sample programs or program segments
that demonstrate the use of the instruction.

Format Notation
Wherever the format for a statement or command is given, the
following rules apply:
1.

Items in capital letters must be input as shown.

2.

Items in lower case letters enclosed in angle
brackets « » are to be supplied by the user.

3.

Items in square brackets ([ ]) are optional.

4.

All punctuation except angle brackets and square
brackets (i.e., commas, parentheses, semicolons,
hyphens, equal signs) must be included where shown.

5.

Items followed by an ellipsis ( ••• ) may be repeated
any number of times (up to the length of the line).

BASIC-SO COMMANDS AND STATEMENTS
2.1

Page 2-2

AUTO

Format:

AUTO [<line number>[,<increment>]]

Versions:

Extended, Disk

Purpose:

To generate a line number
every carriage return.

Remarks:

AUTO begins numbering at <line number> and
increments
each
subsequent line number by
<increment>. The default for -both values is 10.
If <line number> is followed by a comma but
<increment> is not specified, the last increment
specified in an AUTO command is assumed.

automatically

after

If AUTO generates a line number that is already
being used, an asterisk is printed after the
number to warn the user that any input will
replace the existing line. However, typing a
carriage return immediately after the asterisk
will save the line and generate the next line
number.
AUTO is terminated by typing Control-C.
The
line in which Control-C is typed is not saved.
After Control-C is typed, BASIC returns to
command level.
Example:

AUTO 100,50

Generates line numbers 100,
150, 200 •••

AUTO

Generates line numbers 10,
20,30,40 •••

BASIC-SO COMMANDS AND STATEMENTS
2.2

Page 2-3

CALL

Format:

CALL <variable name>[«argument list»]

Version:

Extended, Disk

Purpose:

To call an assembly language subroutine.

Remarks:

The CALL statement is one way to transfer
program flow to an assembly language subroutine.
(See also the OSR function, Section 3.40)
<variable name> contains an address that is the
starting point in memory of the subroutine.
<variable name> may not be an array variable
name.
<argument list> contains the arguments
that are passed to the
assembly
language
subroutine.
<argument list> may not contain
literals.
The CALL statement generates the same calling
sequence used by Microsoft~s FORTRAN, COBOL and
BASIC compilers.

Example:

110 MYROOT=&HDOOO
120 CALL MYROOT(I,J,K)

BASIC-SO COMMANDS AND STATEMENTS
2.3

Page 2-4

CHAIN

Format:

CHAIN [MERGE] <filename>[,[<line number exp>]
[,ALL] [,DELETE<range>]]

Version:

Disk

Purpose:

To call a program and pass variables to it
the current program.

Remarks:

<filename> is the name of the
called. Example:

program

from

that

is

CHAIN"PROGI"
<line number exp> is a line number or an
expression that evaluates to a line number in
the called program. It is the starting point
for execution of the called program. If it is
omitted, execution begins at the first line.
Example:
CHAIN"PROGI",IOOO
<line number exp> is not
command.

affected

by

a

RENUM

With the ALL option, every variable in the
current program is passed to the called programo
If the ALL option is omitted, the current
program must contain a COMMON statement to list
the variables that are passed. See Section 2.7.
Example:
CHAIN"PROGl",IOOO,ALL
If the MERGE option is included, it allows a
subroutine to be brought into the BASIC program
as an overlay. That is, a MERGE operation is
performed with the current program and the
called program. The called program must be an
ASCII file if it is to be MERGEd. Example:
CHAIN MERGE"OVRLAY",lOOO
After an overlay is brought in, it is usually
desirable to delet~ it so that a new overlay may
be brought in.
To do this, use the DELETE
option. Example:
CHAIN MERGE"OVRLAY2",1000,DELETE 1000-5000
The line numbers in <range> are affected by
RENUM command.

the

BASIC-SO COMMANDS AND STATEMENTS

Page 2-5

NOTE:

The Microsoft BASIC compiler does not support
the ALL, MERGE, and DELETE options to CHAIN.
If
you wish to maintain compatibility with the
BASIC compiler, it is recommended that COMMON be
used to pass variables and that overlays not be
used.

NOTE:

The CHAIN statement with MERGE option leaves the
files open and preserves the current OPTION BASE
setting.

NOTE:

If the MERGE option is omitted, CHAIN does not
preserve
variable
types
or
user-defined
functions for use by the chained program.
That
is, any DEFINT, DEFSNG, DEFDBL, DEFSTR, or DEFFN
statements containing shared variables must be
restated in the chained program.

BASIC-SO COMMANDS AND STATEMENTS
2.4

Page 2-6

CLEAR

Format:

CLEAR [,[<expressionl>] [,<expression2>]]

Versions:

SK, -Extended, Disk

Purpose:

To set all numeric variables to zero and all
string variables to null; and, optionally, 'to
set the end of memory and the amount of stack
space.

Remarks:

<expr'essionl> is a memory location which, if
specified, sets the highest location available
for use by BASIC-SO.
<expression2> sets aside stack space for BASIC.
The default is 256 bytes or one-eighth of the
available memory, whichever is smaller.

NOTE:

In previous versions of BASIC-SO, <expressionl>
set
the
amount
of
string
space,' and
<expression2> set the end of memory.
BASIC-80,
release 5.0 and later, allocates string space
dynamically. An ROut of string space error R
occurs only if there is no free memory left for
BASIC to use.

Examples:

CLEAR
CLEAR ,32768
CLEAR ,,2000
CLEAR ,32768,2000

MICROSOFT BASIC COMMANDS AND STATEMENTS
2.5

CLOAD

Formats:

Page 2-7

THIS COMMAND IS NOT INCLUDED IN THE DEC VT180 VERSION

CLOAD <filename>
CLOAD?

<filename>

CLOAD* <array name>
Purpose:

To load a program or an array from cassette tape
into memory.

Remarks:

CLOAD executes a NEW command before it loads the
program from cassette tape. <filename> is, the
string expression or the first character of the
string expression that was specified when the
program was CSAVEd.
CLOAD? verifies tapes by comparing the program
currently in memory with the file on tape that
has the same filename. If they are the same,
BASIC prints Ok. If not, BASIC prints NO GOOD.
CLOAD* loads a numeric array that has been saved
on tape.
The data on tape is loaded into the
array called <array name> specified when the
array was CSAVE*ed.
CLOAD and CLOAD? are always entered at command
level as direct· mode commands. CLOAD* may be
entered at command level or used as a program
statement.
Make
sure the array has been
DIMensioned before it is loaded.
BASIC always
returns to COmmand level after a CLOAD, CLOAD?
or CLOAD* is executed.
Before a CLOAD is
executed, make sure the cassette recorder is
properly connected and in the Play mode, and the
tape is possitioned correctly.
See also CSAVE, Section 2.9.

NOTE:

CLOAD and CSAVE are not
implementations of BASIC.

Example:

CLOAD "MAX2"
Loads file "M" into memory.

included

in

all

MICROSOFT BASIC COMMANDS AND STATEMENTS
2.6

Page 2-8

CLOSE

Format:

CLOSE[[#]<file number>[,[#]<file number ••• >]]

Purpose:

To conclude I/O to a disk file.

Remarks:

<file number> is the number under which the file
was OPENed.
A CLOSE with no arguments closes
all open files.
The association between a particular file and
file number terminates upon execution of a
CLOSE. The file may then be reOPENed using the
same or a different file number; likewise, that
file number may now be reused to OPEN any file.
A CLOSE for a sequential output file writes
final buffer of output.

the

The END statement and the NEW command always
CLOSE all disk files automatically.
(STOP does
not close disk files.)
Example:

See PART II, Chapter 3, Microsoft BASIC
I/O, of the Microsoft BASIC User's Guide.

Disk

BASIC-80 COMMANDS AND STATEMENTS
2.7

Page 2-9

COMMON

Format:

COMMON <list of variables>

Version:

Disk

Purpose:

To pass variables to a CHAINed program.

Remarks:

The COMMON statement is used in conjunction with
the CHAIN statement.
COMMON statements may
appear anywhere in a program, though it is
recommended that they appear at the beginning.
The same variable cannot appear in more than one
COMMON statement. Array variables are specified
by appending "()" to the variable name.
If all
variables are to be passed, use CHAIN with the
ALL option and omit the COMMON statement.

Example:

100 COMMON A,B,C,D(),G$
110 CHAIN "PROG3",10
•

BASIC-80 COMMANDS AND STATEMENTS
2.8

Page 2-10

CONT

Format:

CONT

Versions:

8K, Extended, Disk

Purpose:

To continue program execution after a Control-C
has been typed, or a STOP or END statement has
been executed.

Remarks:

Execution resumes at the point where the break
occurred.
If the break occurred after a prompt
from an INPUT statement, execution continues
with the reprinting of the prompt (7 or prompt
string) •
CONT is usually used in conjunction with STOP
for
debugging.
When execution is stopped,
intermediate values may be examined and changed
using direct mode statements. Execution may be.
resumed with CONT or a direct mode GOTO, which
resumes execution at a specified line number.
With the Extended and Disk versions, CONT may be
used to continue execution after an error.
CONT is invalid if the program has been edited
during the break.
In 8K BASIC-80, execution
cannot be CONTinued if a direct mode error, has
occurred during the break.

Example:

See example Section 2.61, STOP.

BASIC-80 COMMANDS AND STATEMENTS
2.9

CSAVE

Formats:

Page 2-11

THIS COMMAND IS NOT INCLUDED IN THE DEC VT180 VERSION

CSAVE <string expression>
CSAVE* <array variable name>

Versions:

8K (cassette), Extended (cassette)

Purpose:

To save the program or an
memory on cassette tape.

Remarks:

Each program or array saved
on
tape
is
identified by a filename.
When the command
CSAVE <string expression> is executed, BASIC-80
saves the program currently in memory on tape
and uses the first
character
in
<string
expression>
as
the
filename.
<string
expression> may be more than one character, but
only
the first character is used for the
filename.

array

currently

in

When the command CSAVE* <array variable name> is
executed, BASIC-80saves the specified array on
tape. The array must be a numeric array.
The
elements of a multidimensional array are saved
with the leftmost subscript changing fastest.
CSAVE may be used as a program statement or as a
direct mode command.
Before a CSAVE or CSAVE* is executed, make sure
the cassette recorder is properly connected and
in the Record mode.
See also CLOAD, Section 2.5.
NOTE:

CSAVE and CLOAD are not included
implementations of BASIC-80.

Example:

CSAVE "TIMER"
Saves the program currently in memory on
cassette under filename "T".

in

all

BASIC-80 COMMANDS AND STATEMENTS
2.10

Page 2-12

DATA

Format:

DATA <list of constants>

Versions:

8K, Extended, Disk

Purpose:

To store the numeric and string constants that
are accessed by the program~s READ statement(s).
(See READ, Section 2.54)

Remarks:

DATA statements are nonexecutable and may be
placed
anywhere
in
the program.
A DATA
statement may contain as many constants as will
fit on a line (separated by commas), and any
number of DATA statements may be used in a
program.
The READ statements access the DATA
statements in order (by line number)
and the
data contained therein may be thought of as one
continuous list of items, regardless of how many
items are on a line or where the "lines are
placed in the program.
<list of
constants>
may
contain
numeric
constants in any format, i.e., fixed point,
floating point
or
integer.
(No
numeric
expressions are allowed in the list.) String
constants in DATA statements must be surrounded
by double quotation marks only if they contain
commas, colons or
significant
leading
or
trailing spaces. Otherwise, quotation marks are
not needed.
The variable type (numeric or string) given in
the
READ
statement
must
agree with the
corresponding constant in the DATA statement.
DATA statements may be reread from the beginning
by use of the RESTORE statement (Section 2.57).

Example:

See examples in Section 2.54, READ.

BASIC-80 COMMANDS AND STATEMENTS
2.11

Page 2-13

DEF FN

Format:

DEF FN<name>[«parameter list>}]=<function definition>

Versions:

8K, Extended, Disk

Purpose:

To define and name a function that is written by
the user.

Remarks:

<name> must be a legal variable name.
This
name, preceded by FN, becomes the name of the
function.
<parameter list> is comprised of
those variable names in the function definition
that are to be replaced when the function is
called.
The items in the list are separated by
commas. <function definition> is an expression
that performs the operation of the function.
It
is limited to one line.
Variable names that
appear in this expression serve only to define
the function;
they do not affect
program
variables that have the same name. A variable
name used in a function definition mayor may
not appear in the parameter list. If it does,
the value of the parameter is supplied when the
function is called.
Otherwise, the current
value of the variable is used.
The variables in the parameter list represent,
on a one-to-one basis, the argument variables or
values that will be given in the function call.
(Remember, in the 8K version only one argument
is allowed in a function call, therefore the DEF
FN statement will contain only one variable.)
In Extended and Disk BASIC-80, user-defined
functions may be numeric or string; in 8K,
user-defined string functions are not allowed.
If a type is specified in the function name, the
value of the expression is forced to that type
before it is returned to the calling statement.
If a type is specified in the function name and
the argument type does not match, a "Type
mismatch" error occurs.
A DEF FN statement must be executed before the
function
it defines may be called.
If a
function is called before it has been defined,
an "Undefined user function" error occurs. DEF
FN is illegal in the direct mode.

BASIC-SO COMMANDS AND STATEMENTS

Page 2-14

Example:

410 DEF FNAB(X,Y)=X A 3/y A 2
420 T=FNAB (I, J)

Line 410 defines the function
function is called in line 420.

FNAB.

The

BASIC-SO COMMANDS AND STATEMENTS
2.12

Page 2-15

DEFINT/SNG/DBL/STR

Format:

DEF<type> <range(s) of letters>
where <type> is INT, SNG, DBL, or STR

Versions:

Extended, Disk

Purpose:

To declare variable types as integer,
precision, double precision, or string.

Remarks:

A DEFtype statement declares that the variable
names beginning with the 1etter(s) specified
will be that type variable.
However, a type
declaration character always takes precedence
over a DEFtype statement in the typing of a
variable.

single

If
no
type
declaration
statements
are
encountered,
BASIC-SO assumes all variables
without declaration
characters
are
single
precision variables.
Examples:

10 DEFDBL L-P

All variables beginning with
the letters L, M, N, 0, and P
will be double precision
variables.

10 DEFSTR A

All variables beginning with
the letter A will be string
variables.

10 DEFINT I-N,W-Z
All variable beginning with
the letters I, J, K, L, M,
N, W, X, Y, Z will be integer
variables.

BASIC-80 COMMANDS AND STATEMENTS
2.13

~

Page 2-16

USR

Format:

DEF USR[<digit>]=<integer expression>

Versions:

Extended, Disk

Purpose:

To specify the starting address of
language subroutine.

Remarks:

<digit> may be any digit from 0 to 9. The digit
corresponds to the number of the USR routine
whose address is being specified. If <digit> is
omitted, DEF USRO is assumed.
The value of
<integer expression> is the starting address of
the USR routine.
See Appendix C, Assembly_
Language Subroutines.

an

assembly

Any number of DEF USR statements may appear in a
program
to
redefine
subroutine
starting
addresses, thus allowing access to as many
subroutines as necessary.
_ Example:

•

.

200 DEFUSRO=24000
210 X=USRO(y A 2/2.89)

."

BASIC-80 COMMANDS AND STATEMENTS
2.14

Page 2-17

DELETE

Format:

DELETE[<line number>] [-<line number>]

Versions:

Extended, Disk

Purpose:

To delete program lines.

Remarks:

BASIC-80 always returns to command level after a
DELETE is executed. If <line number> does not
exist, an "Illegal function call" error occurs.

Examples:

DELETE 40

Deletes line 40

DELETE 40-100

Deletes lines 40 through
100, inclusive

DELETE-40

Deletes all lines up to
and including line 40

BASIC-80 COMMANDS AND STATEMENTS
2.15

Page 2-18

DIM

Format:

DIM <list of subscripted variables>

Versions:

8K, Extended, Disk

Purpose:

To specify the maximum values for array variable
subscripts and allocate storage accordingly.

Remarks:

If an array variable name is used without a DIM
statement, the maximum value of its subscript(s)
is assumed to be 10. If a subscript is used
that is greater than the maximum specified, ,a
"Subscript out of range" error occurs.
The
minimum value for a subscript is always 0,
unless otherwise specified with the OPTION BASE
statement (see Section 2.46).
The DIM statement sets all the elements of the
specified arrays to an initial value of zero.

Example:

10 DIM A(20)
20 FOR 1=0 TO 20
30 READ A(I)
40 NEXT I
•

BASIC-SO COMMANDS AND STATEMENTS
2.16

Page 2-19

EDIT

Format:

EDIT <line number>

Versions:

Extended, Disk

Purpose:

To enter Edit Mode at the specified line.

Remarks:

In Edit Mode, it is possible to edit portions of
a line without retyping the entire line. Upon
entering Edit Mode, BASIC-SO types the line
number of the line to be edited, then it types a
space and waits for an Edit Mode subcommand.
Edit ---Mode Subcommands
----

~~~~~~

Edit Mode subcommands are used to move the
cursor or to insert, delete, replace, or search
for text within a line. The subcommands are not
echoed.
Most of the Edit Mode subcommands may
be preceded by an integer which causes the
command to be executed that number of times.
When a preceding integer is not specified, it is
assumed to be 1.
Edit Mode subcommands
may
be
categorized
according to the following functions:

1.

Moving the cursor

2.

Inserting text

3.

Deleting text

4.

Finding text

5.

Replacing text

6.

Ending and restarting Edit Mode

N~E

In the descriptions that follow,
<ch>
represents
any
character,
<text>
represents a string of characters of
arbitrary
length,
[iJ
represents an
optional integer (the default is 1), and
$ represents the Escape
(or Altmode)
key.

BASIC-SO COMMANDS AND STATEMENTS
1.

2.

3.

4.

Page 2-20

Moving the Cursor
Space

Use the space bar to move the cursor to the
right.
[iJSpace moves the cursor i spaces to
the right. Characters are printed as you space
over them.

Rubout

In Edit Mode,
[i]Rubout moves the cursor i
spaces to the left (backspaces). Characters are
printed as you backspace over them.

Inserting Text
I

I<text>$ inserts <text> at the current cursor
position.
The inserted characters are printed
on the terminal. TO terminate insertion, type
Escape.
If Carriage Return is typed during an
Insert command, the effect is the same as typing
Escape and then Carriage Return.
During an
Insert command, the Rubout or Delete key on the
terminal may be used to delete characters to the
left of the cursor. If an attempt is made to
insert a character that will make the line
longer than 255 characters, a bell (Control-G)
is typed and the character is not printed.

X

The X subcommand is used to extend the line.
X
• mo.ves 'the '" cursor to the end of the line, goes
into insert mode, and allows insertion of text
as if an Insert command had been given. When
you are finished extending the line, type Escape
or Carriage Return.

Oeleting'Te~t

o

[i]D deletes i characters to the right of the
cursor.
The deleted characters are echoed
between
backslashes,
and
the
cursor
is
positioned to the right of the last character
deleted. If there are fewer than i characters
to the right of the cursor, iO deletes the
remainder of the line.

H

H deletes all characters to the
curSQr and then automatically
mode. H is useful for replacing
the end of a line.

right of the
enters insert
statements at

Finding Text
S

The subcommand [i]S<ch> searches for the ith
occurrence of <ch> and positions the cursor
before it. The character at the current cursor
position is not included in the search. If <ch>
is not found, the cursor will stop at the end of

BASIC-80 COMMANDS AND STATEMENTS

Page 2-21

the line. All characters passed over during the
search are printed.
K

s.

Replacing Text
C

6.

The subcommand [i]K<ch> is similar to [i]S<ch>,
except all the characters passed over in the
search are deleted. The cursor is positioned
before <ch>, and the deleted characters are
enclosed in backslashes.

The subcommand C<ch> changes the next character
to <ch>.
If you wish to change the next i
characters, use the subcommand iC, followed by i
characters.
After the ith new character is
typed, change mode is exited and you will return
to Edit Mode.

Ending and Restarting Edit Mode
<cr>

Typing Carriage Return prints the remainder of
the line, saves the changes you made and exits
Edit Mode.

E

The E subcommand has the same effect as Carriage
Return, except the remainder of the line is not
printed.

Q

The Q subcommand returns to BASIC-80 ..¥command
"
level, without saving any of the changes that
were made to the line during Edit Mode.

L

The L subcommand lists the remainder of the line
(saving any changes made so far) and repositions
the cursor at the beginning of the line, still
in Edit Mode.
L
is usually used to list the
line when you first enter Edit Mode.

A

The A subcommand lets you begin editing a line
over again.
It restores the original line and
repositions the cursor at the beginning.
NOTE
If BASIC-80 receives an unrecognizable
command or illegal character while in
Edit Mode, it prints a bell (Control-G)
and the command or character is ignored.

BASIC-SO COMMANDS AND STATEMENTS

Page 2-22

Syntax Errors
When a Syntax Error is encountered
during
execution of a program, BASIC-SO automatically
enters Edit Mode at the line that caused the
error. For example:
10 K = 2(4)
RON
?Syntax error in 10
10
When you finish editing the line and type
Carriage Return (or the E subcommand), BASIC-SO
reinserts the line, which causes all variable
values to be lost.
To preserve the variable
values for examination , first exit Edit Mode
with the 0 subcommand. BASIC-SO will return to
command level, and all variable values will be
preserved.
Control-A
To enter Edit Mode on the line you are currently
typing, type Control-A. BASIC-SO responds with
a carriage return, an exclamation point (1) and
a space.
The cursor will be positioned at the
first character in the line. Proceed by typing
an Edit Mode subcommand.
NOTE
Remember, if you have just entered a
line and wish to go back and edit it,
the command nEDIT.n will enter Edit Mode
at the current line.
(The line number
symbol n.n always refers to the current
line. )

BASIC-SO COMMANDS AND STATEMENTS
2.17

Page 2-23

END

Format:

END

Versions:

SK, Extended, Disk

Purpose:

To terminate program execution, close all
and return to command level.

Remarks:

END statements may be placed anywbere in the
program to terminate execution. Unlike the STOP
statement, END does not cause a BREAK message to
be printed.
An END statement at the end of a
program is optional. BASIC-aO·always returns to
command level after an END is executed.

Example:

520 IF K>lOOO THEN END ELSE GOTO 20

files

BASIC-80 COMMANDS AND STATEMENTS
2.18

Page 2-24

ERASE

Format: .

ERASE <list of array variables>

Versions:

Extended, Disk

Purpose:

To eliminate arrays from a program.

Remarks:

Arrays may be redimensioned after they are
ERASEd, or the previously allocated array space
in memory may be used for other purposes. If an
attempt is made to redimension an array without
first ERASEing it, a "Redimensioned array" error
occurs.

NOTE:

The Microsoft BASIC compiler
ERASE.

Example:
450 ERASE A,B
460 DIM B(99)
•
•

does

not

support

BASIC-80 COMMANDS AND STATEMENTS
2.19

Page 2-25

ERR AND ERL VARIABLES
When an error handling subroutine is entered,
the variable ERR contains the error code for the
error, and the variable ERL contains the line
number of the line in which the error ·was
detected. The ERR and ERL variables are usually
used in IF ••• THEN statements to direct program
flow in the error trap routine.
If the statement that caused the error was a
direct mode statement, ERL will contain 65535.
To test if an error occurred in a direct
statement, use IF 65535 = ERL THEN •••
Otherwise, use
IF ERR = error code THEN •••
IF ERL

= line number THEN •••

If the line number is not on the right side of
the relational operator, it cannot be renumbered
by RENUM.Because ERL and ERR are reserved
variables, neither may appear to the left of the
equal sign in a LET (assignment)
statement.

BASIC-80 COMMANDS AND STATEMENTS
2.20

Page 2-26

ERROR

Format:

ERROR <integer expression>

Versions:

Extend~d,

Purpose:

1) To simulate the occurrence of a BASIC-80
error1
or 2) to allow error codes to be
defined by the user.

Remarks:

The value of <integer expression> must
be
greater than 0 and less than 255. If the value
of <integer expression> equals an error code
already in use by BASIC-80 (see Appendix J), the
ERROR statement will simulate the occurrence of
that error, and the corresponding error message
will be printed. (See Example 1.)

Disk

To define your own error code, use a value that
is greater than any used by BASIC-80~s error
codes. (It is preferable to use the highest
available
values,
so compatibility may be
maintained when more error codes are added to
BASIC-80.) This user-defined error code may then
be conveniently handled in an
error
trap
routine. (Se..e Example 2.)
If an ERROR statement specifies a CQcle for which
no error message has been defined, BASIC-80
responds with the message UNPRINTABLE ERROR.
Execution of an ERROR statement for which there
is no error trap routine causes an error message
to be printed and execution to halt.
Example 1:

LIST
10 S = 10
20 T = 5
30 ERROR S + T
40 END
Ok
RUN
String too long in line 30
Or, in direct mode:
Ok
ERROR 15
String too long
Ok

(you type this line)
(BASIC-80 types this line)

BASIC-SO COMMANDS AND STATEMENTS

Page 2-27

Example 2:

.

110 ON ERROR GOTO 400
120 INPUT "WHAT IS YOUR BET";B
130 IF B > 5000 THEN ERROR 210

400 IF ERR = 210 THEN PRINT "HOUSE LIMIT IS $5000"
410 IF ERL = 130 THEN RESUME 120

BASIC-80 COMMANDS AND STATEMENTS
2.21

Page 2-28

FIELD

Format:

FIELD[i]<file number>,<field width> AS <string variable> •••

Version:

Disk

Purpose:

To allocate space for variables in a random file
buffer.

Remarks:

To get data out of a random buffer after a GET
or to enter data before a PUT, a FIELD statement
must have been executed.
<file number> is the number und~r which the file
was OPENed.
<field width> is the number of
characters to be allocated to <string variable>.
For example,
FIELD 1, 20 AS N$, 10 AS ID$, 40 AS ADD$
allocates the first 20 positions. (bytes) in the·
random file buffer to the string variable N$,
the next 10 positions to ID$, and the next 40
positions to ADD$.
FIELD does NOT place any
data in the random file buffer.
(See LSET/RSET
and GET.)
The total number of bytes allocated in a FIELD
statement must not exceed the record length that
was specified when the
file
was
OPENed.
Otherwise, a "Field overflow" error occurs.
(The default record length is l28.)
Any number of FIELD statements may be executed
for the same file, and all FIELD statements that
have been executed are in effect at the same
time.

Example:

See Appendix B.

NOTE:

!!2! ~ a FIELDed var iable name in an I.NPUT
or LET statement.
Once a -viriable--name is
FIELDed, it points to the correct place in the
random file buffer.
If a subsequent INPUT or
LET statement with that variable
name
is
executed, the variable~s pointer is moved to
string space.
~

BASIC-SO COMMANDS AND STATEMENTS
2.22

Page 2-29

FOR ••• NEXT

Format:

FOR <variable>=x TO y [STEP z]

NEXT [<variable>] [,<variable> ••• ]
where x, y and z are numeric expressions.
Versions:

SK, Extended, Disk

Purpose:

To allow a series of instructions
to
performed in a loop a given number of times.

Remarks:

<variable> is used as a counter.
The first
numeric expression (x) is the initial value of
the counter. The second numeric expression (y)
is the final value of the counter. The program
lines following the FOR statement are executed
until the NEXT statement is encountered. Then
the counter is incremented by
the
amount
specified by STEP. A check is performed to see
if the value of the counter is now greater than
the final value (y).
If it is not greater,
BASIC-SO branches back to the statement after
the FOR· statement and the process is repeated.
If it is greater, execution continues with the
statement following the NEXT statement. This is
a FOR ••• NEXT loop. If STEP is not specified,
the increment is assumed to be one. If STEP is
negative, the final value of the counter is set
to be less than the initial value. The counter
is decremented each time through the loop, and
the loop is executed until the counter is less
than the final value.

be

The body of the loop is skipped if the initial
value of the loop times the sign of the step
exceeds the final value times the sign of the
step.
Nested Loops
FOR ••• NEXT loops may be nested, that is, a
FOR ••• NEXT loop may be placed within the context
of another FOR ••• NEXT loop.
When loops are
nested, each loop must have a unique variable
name as its counter. The NEXT statement for the
inside loop must appear before that for the
outside loop. If nested loops have the same end
point, a single NEXT statement may be used for
all of them.
The variable(s) in the

NEXT

statement

may

be

BASIC-SO COMMANDS AND STATEMENTS

Page 2-30

omitted, in which case the NEXT statement will
match the most recent FOR statement. If a NEXT
statement
is
encountered
before
its
corresponding FOR statement, a "NEXT without
FOR" error message is issued and execution is
terminated.
Example 1:

10 1(=10
20 FOR I=l TO I( STEP 2
30 PRINT I;
40 1(=1(+10
50 PRINT I(
60 NEXT
RUN
1 20
3 30
5 40
7 50
9 60
Ok

Example 2:

10 J-O
20 FOR I=l TO J
30 PRINT I
40 NEXT I
In this example, the loop does( not execute
because the initial value of the loop exceeds
the final value.

Example 3:

10 I=5
20 FOR I=l TO I+5
30 PRINT I;
40 NEXT
RUN
1 2 3 4 5 6
Ok

7

8

9

10

In this example, the loop executes ten times.
The final value for the loop variable is always
set before the initial value is set.
(Note:
Previous versions of BASIC-SO set the initial
value of the loop variable before setting the
final value;
i.e., the above loop would have
executed six times.)

BASIC-SO COMMANDS AND STATEMENTS
2.23

Page 2-31

GET

Format:

GET [#]<file number>[,<record number>]

Version:

Disk

Purpose:

To read a record from a random disk file into
random buffer.

Remarks:

<file number> is the number under which the file
was OPENed. If <record number> is omitted, the
next record (after the last GET)
is read into
the buffer. The largest possible record number
is 32767.

Example:

See Appendix B.

NOTE:

After a GET statement, INPUT# and LINE INPUT#
may be done to read characters from the random
file buffer.

a

BASIC-80 COMMANDS AND STATEMENTS
2.24

Page 2-32

GOSUB •.. RETURN

Format:

GOSUB <line number>

RETURN
Versions:

8K, Extended, Disk

Purpose:

To branch to and return from a subroutine.

Remarks:

<line number>
subroutine.

is

the

first

line

of

the

A subroutine may be called any number of times
in a program, and a subroutine may be called
from within another subroutine. Such nesting of
subroutines is limited only by available memory.
The RETURN statement(s) in a subroutine cause
BASIC-80
to
branch back to the statement
following the most recent GOSUB statement.
A
subroutine may contain more than one RETURN
statement, should logic dictate a return at
different points in the subroutine. Subroutines
may appear anywhere in the program, but it is
recommended
that the subroutine be readily
distinguishable from the main program.
To
prevent inadvertant entry into the subroutine,
it may be preceded by a STOP, END, or GOTO
statement that directs program control around
the subroutine.
Example:

10 GOSUB 40
20 PRINT "BACK FROM SUBROUTINE"
30 END
40 PRINT "SUBROUTINE" ;
50 PRINT " IN";
60 PRINT n PROGRESS"
70 RETURN
RUN
SUBROUTINE IN PROGRESS
BACK FROM SUBROUTINE
Ok

BASIC-SO COMMANDS AND STATEMENTS
2.25

Page 2-33

GOTO

Format:

GOTO <line number>

Versions:

SK, Extended, Disk

Purpose:

To branch unconditionally out of the normal
program sequence to a specified line number.

Remarks:

If <line number> is an executable statement,
that statement and those following are executed.
If it is a nonexecutable statement, execution
proceeds
at the first executable statement
encountered after <line number>.

Example:

LIST
10 READ R
20 PRINT "R =" :R,
30 A = 3.l4*R .... 2
40 PRINT "AREA =" :A
50 GOTO 10
60 DATA 5,7,12
Ok
RUN
R = 5
AREA = 7S.5
R = 7
AREA = l53.S6
R = 12
AREA = 452.16
?Out of data in 10
Ok

BASIC-SO COMMANDS AND STATEMENTS
2.26

Page 2-34

IF ••• THEN[ ••• ELSE] AND IF ••• GOTO
---

Format:

IF <expression> THEN <statement(s»

<line number>

,

[ELSE <statement(s)>
Format:

I <line number>]

IF <expression> GOTO <line number>
[ELSE <statement(s)>

I <line number>]

Versions:

SK, Extended, Disk

NOTE:

The ELSE clause is allowed only in Extended
Disk versions.

and

Purpose:

To make a decision regarding program flow
on the result returned by an expression.

based

Remarks:

If the result of <expression> is not zero, the
THEN or GOTO clause is executed. THEN may be
followed by either a line number for branching
or one or more statements to be executed. GOTO
is always followed by a line number.
If the
result of <expression> is zero, the THEN or GOTO
clause is ignored and the ELSE clause, if
present, is executed. Execution continues with
the next executable statement.
(ELSE is allowed
only -in Extended and Disk versions.) Extended
and Disk versions allow a comma before THEN.
Nesting of IF Statements
In
the
Extended
and
Disk
versions,
IF ••• THEN ••• ELSE
statements
may be nested.
Nesting is limited only by the length of the
line. For example
IF X>Y THEN PRINT "GREATER" ELSE IF Y>X
THEN PRINT "LESS THAN" ELSE PRINT "EQUAL"
is a legal statement. If the statement does not
contain
the same number of ELSE and THEN
clauses, each ELSE is matched with the closest
unmatched THEN. For example
IF A=B THEN IF B=C THEN PRINT "A=C"
ELSE PRINT "A<>C"
will not print nA<>C" when A<>B.
If an IF ••• THEN statement is followed by a line
number in the direct mode, an "Undefined line"
the
error results unless a statement with
specified
line
number had previously been
entered in the indirect mode.

BASIC-SO COMMANDS AND STATEMENTS
NOTE:

Page 2-35

When using IF to test equality for a value that
is the result of a floating point computation,
remember that the internal representation of the
value may not be exact. Therefore, the test
should be against the' range over which the
accuracy of the value may vary. For example, to
test a computed variable 'A against the value
1.0, use:
IF ABS (A-1.0)<1.0E-6 THEN •••
This test returns true if the value of A is
with a relative error of less than 1.OE-6.

Example 1:

200 IF I THEN GETt1,I
This statement GETs record number I if I is
zero.

Example 2:

1.0

not

100 IF(I<20)*(I>10) THEN DB=1979-1:GOTO 300
110 PRINT "OUT OF RANGE"

In this example, a test determines if I
is
greater than 10 and less than 20. If I is in
this range, DB is calculated and execution
branches to line 300.
If I is not in this
range, execution continues with line 110.
Example 3:

210 IF IOFLAG THEN PRINT A$ ELSE LPRINT A$
This statement causes printed output to go
either to the terminal or the line printer,
depending on the value of a variable
(IOFLAG).
If I OF LAG is zero, output goes to the line
printer, otherwise output goes to the terminal.

BASIC-80 COMMANDS AND STATEMENTS
2.27

Page 2-36

INPUT

Format:

INPUT[:] [<"prompt string">:]<list of variables>

Versions:

8K, Extended, Disk

Purpose:

To allow input from the terminal during
execution.

Remarks:

When an INPUT statement is encountered, program
execution pauses and a question mark is printed
to indicate the program is waiting for data.
If
<"prompt string"> ~s included, the string is
printed before the question mark. The required
data is then entered at the terminal.

program

A comma may be used instead of a semicolon after
the prompt string to suppress the question mark.
For example,
the
statement
INPUT
"ENTER
BIRTHDATE",B$ will print the prompt with no
question mark.
If INPUT is immediately followed by a semicolon,
then the carriage return typed by the user to
input data does not echo a carriage return/line
feed sequence.
The data that is entered is assigned to the
variable(s)
given in <variable list>.
The
number of data items supplied must be the same
as the number of variables in the list. Data
ttems are separated by commas.
The variable names in the list may be numeric or
string variable names
(including subscripted
variables). The type of each data item that is
input must agree with the type specified by the
variable name.
(Strings input to an INPUT
statement need not be surrounded by quotation
marks.)
Responding to INPUT with too many or too few
items, or with the wrong type of value (numeric
instead of string, etc.) causes the messsage
"?Redo from start" to be printed. No assignment
of input values is made until an acceptable
response is given.
In the 8K version,
direct mode.

INPUT

is

illegal

in

the

BASIC-80 COMMANDS AND STATEMENTS
Examples:

Page 2-37

10 INPUT x
20 PRINT X "SQUARED IS" X"'2
30 END
RUN
(The 5 was typed in by the user
? 5
in response to the question mark.)
5 SQUARED IS 25
Ok
LIST
10 PI=3.14
20 INPUT "WHAT IS THE RADIUS":R
30 A=PI*R"'2
40 PRINT "THE AREA OF THE CIRCLE IS":A
50 PRINT
60 GOTO 20
Ok
RUN
WHAT IS THE RADIUS? 7.4 (User types 7.4)
THE AREA OF THE CIRCLE IS 171.946
WHAT IS THE RADIUS?
etc.

BASlc-ao COMMANDS AND STATEMENTS
2.2a

Page 2-38

INPUT#

Format:

INPUT#<file number>,<variable list>

Version:

Disk

Purpose:

To read data items from a sequential disk
and assign them to program variables.

Remarks:

<file number> is the number used when the file
was OPENed for input. <variable list> contains
the vari?lble names that will be assigned to the
items in the file.
(The variable type must
match the type specified by the variable name.)
With INPUT#, no question mark is printed, as
with INPUT.

file

The data items in the file should appear just as
they would if data were being typed in response
to an INPUT statement.
with numeric values,
leading spaces, carriage returns and line feeds
are ignored. The first character encountered
that is not a space, carriage return or line
feed is assumed to be the start of a number.
The number terminates on a space, carriage
return, line feed or comma.
If BASIC-aO is scanning the sequential data file
for a string item, leading spaces, carriage
returns and line feeds are also ignored.
The
first character encountered that is not a space,
carriage return, or line feed is assumed to be
the start of a string item.
If this first
character is a quotation mark
("), the string
item will consist of all characters read between
the first quotation mark and the second.
Thus,
a quoted string may not contain a quotation mark
as a character. If the first character of the
string is not a quotation mark, the string is an
unquoted string, and will terminate on a comma,
carriage or line feed (or after 255 characters
have been read). If end of file is reached when
a numeric or string item is being INPUT, the
item is terminated.
Example:

See Appendix B.

BASIC-SO COMMANDS AND STATEMENTS
2.29

Page 2-39

KILL

Format:

KILL <filename>

Version:

Disk

Purpose:

To delete a file from disk.

Remarks:

If a KILL statement is given for a file that is
currently OPEN, a RFile already open R error
occurs.
KILL is used for all types of disk files:
program files, random data files and sequential
data files.

Example:

200 KILL RDATA1R
See also Appendix B.

Page 2-40

BASIC-80 COMMANDS AND STATEMENTS
2.30

LET

Format:

[LET] <variable>=<expression>

Versions:

8K, Extended, Disk

Purpose:

To assign
variable.

Remarks:

Notice the word LET is optional, i.e., the equal
sign is sufficient when assigning an expression
to a variable name.

Example:

110 LET 0=12
120 LET E=12A2
130 LET F=12A4
140 LET SUM=D+E+F

the

or
110
120
130
140

D=12
E=12"'2
F=12 .... 4
SUM=D+E+F

value

of

an

expression

to

a

BASIC-80 COMMANDS AND STATEMENTS
2.31

Page 2-41

LINE INPUT

Format:

LINE INPUT[i] [<"prompt string">i]<string variable>

Versions:

Extended, Disk

Purpose:

To input an entire line (up to 254 characters)
to
a string variable, without the use of
delimiters.

Remarks:

The prompt string is a string literal that is
printed
at
the
terminal before input is
accepted. A question mark is not printed unless
it is part of the prompt string. All input from
the end of the prompt to the carriage return is
assigned to <string variable>.
If LINE INPUT is immediately followed by a
semicolon, then the carriage return typed by the
user to end the input line does not echo a
carriage
return/line
feed sequence at the
terminal.
A LINE INPUT may be escaped by typing Control-C.
BASIC-SO will return to command level and type
Ok. Typing CONT resumes execution at the LINE
INPUT.

Example:

See Example, Section 2.32, LINE INPUT#.

BASIC-SO COMMANDS AND STATEMENTS
2.32

~

Page 2-42

INPUTi

Format:

LINE INPUTi<file number>,<string variable>

Version:

Disk

Purpose:

To read an entire line (up to 254 characters),
without delimiters, from a sequential disk data
file to a string variable.

Remarks:

<file number> is the number under which the file
was OPENed.
<string variable> is the variable
name to which the 'line will be assigned.
LINE
INPUTi reads all characters in the sequential
file up to a carriage return.
It then skips
over the carriage return/line feed sequence, and
the next LINE INPUTi reads all characters up to
the
next
carriage
return.
(If
a line
feed/carriage return sequence is encountered, it
is preserved.)
LINE INPUTi is especially useful if each line of
a data file has been broken into fields, or if a
BASIC-SO program saved in ASCII mode is being
read as data by another program.

Example:

10 OPEN "O",l,"LIST"
20 LINE INPUT "CUSTOMER INFORMATION? " :C$
30 PRINT iI, C$
40 CLOSE 1
50 OPEN "I",l,"LIST"
60 LINE INPUT iI, C$
70 PRINT C$
SO 'CLOSE 1
RUN
234,4
CUSTOMER INFORMATION? LINDA JONES
234,4
MEMPHIS
LINDA JONES
Ok

MEMPHIS

BASIC-80 COMMANDS AND STATEMENTS
2.33

Page 2-43

LIST

Format 1:

LIST [<line number>]

Versions:

8K, Extended, Disk

Format 2:

LIST [<line number>[-[<line number>]]]

Versions:

Extended, Disk

Purpose:

To list all or part of the program currently
memory at the terminal.

Remarks:

BASIC-80 always returns to command level after a
LIST is executed.

in

Format 1: If <line number> is omitted,
the
program is listed beginning at the lowest line
number.
(Listing is terminated either by the
end of the program or by typing Control-C.) If
<line number> is included, the 8K version will
list the program beginning at that line: and
the Extended and Disk versions will list only
the specified line.
Format 2:
options:

This

format

allows

the

following

1.

If only the first number is specified, that
line
and all higher-numbered lines are
listed.

2.

If only the second number is specified, all
lines from the beginning of the program
through that line are listed.

3.

If both numbers are
range is listed.

specified,

the

entire

BASIC-80 COMMANDS AND STATEMENTS
Examples:

Page 2-44

Format 1:
LIST

Lists the program currently
in memory.

LIST 500

In the 8K version, lists
all programs lines from
500 to the end.
In Extended and Disk,
lists line 500.

Format 2:
LIST 150-

Lists all lines from 150
to the end.

LIST -1000

Lists all lines from the
lowest number through 1000.

LIST 150-1000

Lists lines 150 through
1000, inclusive.

BASIC-80 COMMANDS AND STATEMENTS
2.34

Page 2-45

LLIST

Format:

LLIST [<line number>[-[<line number>]]]

Versions:

Extended, Disk

Purpose:

To list all or part of the program currently
memory at the line printer.

Remarks:

LLIST assumes a l32-character wide printer.

in

BASIC-80 always returns to command level after
an LLIST is executed. The options for LLIST are
the same as for LIST, Format 2.
NOTE:

LLIST and LPRINT are not
implementations of BASIC-80.

Example:

See the examples for LIST, Format 2.

included

in

all

BASIC-SO COMMANDS AND STATEMENTS
2.35

Page 2-46

LOAD

Format:

LOAD <filename>[,R]

Version:

Disk

Purpose:

To load a file from disk into memory.

Remarks:

<filename> is the name that was used when the
file
was
SAVEd.
(With CP/M, the default
extension .BAS is supplied.)
LOAD closes all open files and deletes all
variables and program lines currently residing
in memory before it loads
the
designated
program.
However, if the nRn option is used
with LOAD, the program is RUN after it is
LOADed, and all open data files are kept open.
Thus, LOAD with the nRn option may be used to
chain several programs (or segments of the same
program). Information may be passed between the
programs using their disk data files.

Example:

LOAD nSTRTRKn,R

BASIC-80 COMMANDS AND STATEMENTS
2.36

Page 2-47

LPRINT AND LPRINT USING

Format:

LPRINT [<list of expressions>]
LPRINT USING <string exp>i<list of expressions>

Versions:

Extended, Disk

Purpose:

To print data at the line printer.

Remarks:

Same as PRINT and PRINT USING, except output
goes to the line printer. See Section 2.49 and
Section 2.50.
LPRINT assumes a l32-character-wide printer.

NOTE:

LPRINT and LLIST are not
implementations of BASIC-80.

included

in

all

BASIC-80 COMMANDS AND STATEMENTS
2 • 37

Page 2-48

LSET AND RSET

Format:

LSET <string variable> = <string expression>
RSET <string variable> = <string expression>

Version:

Disk

Purpose:

To move data from memory to a random file buffer
(in preparation for a PUT statement) •

Remarks:

If <string expression> requires fewer bytes than
were
FIELDed
to
<string
variable>, LSET
left-justifies the string in the field, and RSET
right-justifies the string.
(Spaces are used to
pad the extra positions.) If the string is too
long for the field, characters are dropped from
the right. Numeric values must be converted to
strings before they are LSET or RSET. See the
MKI$, MKS$, MKD$ functions, Section 3.25.

Examples:

150 LSET A$=MKS$(AMT)
160 LSET D$=DESC($~
See also Appendix B.

NOTE:

LSET or RSET may also be used with a non-fielded
string variable to left-justify or right-justify
a string in a given field.
For example, the
program lines
110 A$=SPACE$(20)
120 RSET A$=N$
right-justify the string N$ in a 20-character
field.
This can be very handy for formatting
printed output.

BASIC-80 COMMANDS AND STATEMENTS
2.38

Page 2-49

MERGE

Format:

MERGE <filename>

Version:

Disk

Purpose:

To merge a specified disk file into the
currently in memory.

Remarks:

<filename> is the name used when the file was
SAVEd.
(With CP/M, the default extension .BAS
is supplied.) The file must have been SAVEd in
ASCII format.
(If not, a "Bad file mode" error
occurs. )

program

If any lines in the disk file have the same line
numbers as lines in the program in memory, the
lines from the file on disk will replace the
corresponding lines in memory.
(MERGEing may be
thought of as "inserting" the program lines on
disk into the program in memory.)
BASIC-80 always returns to command
executing a MERGE command.
Example:

MERGE "NUMBRS"

level

after

BASIC-SO COMMANDS AND STATEMENTS
2.39

Page 2-50

MID$

Format:

MID$«string expl>,n[,m])=<string exp2>
_where nand m are integer expressions and
<string expl> and <string exp2> are string
expressions.

Versions:

Extended, Disk

Purpose:

To replace a portion of one string with
string.

Remarks:

The characters in <string expl>, beginning at
position n, are replaced by the characters in
<string exp2>. The optional m refers, to the
number of characters from <string exp2> that
will be used in the replacement.
If m is
omitted, all of <string exp2> is used. However,
regardless of whether m is omitted or included,
the replacement of characters never goes beyond
the original length of <string expl>.

Example:

10 A$="KANSAS CITY, MO"
20 MID$(A$,14)="KS"
30 PRINT A$
RUN
KANSAS CITY, KS

another

MID$ is also a function that returns a substring
of a given string. See Section 3.24.

BASIC-80 COMMANDS AND STATEMENTS
2.40

Page 2-51

NAME

Format:

NAME <old filename> AS <new filename>

Version:

Disk

Purpose:

To change the name of a disk file.

Remarks:

<old filename> must exist and <new filename>
must not exist; otherwise an error will result.
After a NAME command, the file exists on the
same disk, in the same area of disk space, with
the new name.

Example:

Ok
NAME "ACCTS" AS "LEDGER"
Ok
In this example, the file that was
formerly named ACCTS will now be named LEDGER.

BASIC-80 COMMANDS AND STATEMENTS
2.41

Page 2-52

NEW

Format:

NEW

Versions:

8K, Extended, Disk

Purpose:

To delete the program currently
clear all variables.

Remarks:

NEW is entered at command leyel to clear memory
before entering a new program. BASIC-80 always
returns to command level after a
NEW
is
executed.

in

memory

and

BASIC-80 COMMANDS AND STATEMENTS
2.42

Page 2-53

NULL

Format:

NULL <integer expression>

Versions:

8K, Extended, Disk

Purpose:

To set the number of nulls to be printed at
end of each line.

Remarks:

For
10-character-per-second
tape
punches,
<integer expression> should be >=3. When tapes
are not being punched, <integer expression>
should
be
0
or
1
for
Teletypes
and
Teletype-compatible CRTs. <integer expression>
should be 2 or 3 for 30 cps hard copy printers.
The default value is O.

Example:

Ok
NULL 2
Ok
100 INPUT X
200 IF X<50 GOTO 800

the

Two null characters will be printed after each
line.

BASIC-SO COMMANDS AND STATEMENTS
2.43

Page 2-54

ON ERROR GOTO

Format:

ON ERROR GOTO <line number>

Versions:

Extended, Disk

Purpose:

To enable error trapping and specify the
line of the error handling subroutine.

Remarks:

Once error trapping has been enabled all errors
detected, including direct mode errors (e.g.,
Syntax errors), will cause a jump to
the
specified error handling subroutine. If <line
number> does not exist, an "Undefined line"
error
results.
To disable error trapping,
execute an ON ERROR ~TO O.
Subsequent errors
will print an error message and halt execution.
An ON ERROR GOTO 0 statement that appears in an
error trapping subroutine causes BASIC-SO to
stop and print the error message for the error
that caused the trap.
It is recommended that
all error trapping subroutines execute an ON
ERROR GOTO 0 if an error is encountered for
which there is no recovery action.

NOTE:

If an error occurs during execution of an error
handling subroutine, the BASIC error message is
printed
and
execution
terminates.
Error
trapping
does
not occur within the error
handling subroutine.

Example:

10 ON ERROR GOTO 1000

first

BASIC-SO COMMANDS AND STATEMENTS
2.44

Page 2-55

ON ••• GOSUB AND ON ••• GOTO

Format:

ON <expression> GOTO <list of line numbers>
ON <expression> GOSUB <list of line numbers>

Versions:

SK, Extended, Disk

Purpose:

To branch to one of several specified line
numbers, depending on the value returned when an
expression is evaluated.

Remarks:

The value of <expression> determines which line
number in the list will be used for branching.
For example, if the value is three, the third
line number in the list will be the destination
of the branch.
(If the value is a non-integer,
the fractional portion is rounded.)
In the ON ••• GOSUB statement, each line number in
the list must be the first line number of a
subroutine.
If the value of <expression> is zero or greater
than the number of items in the list (but less
than or equal to 255), BASIC continues with the
next executable statement.
If the value of
<expression> is negative or greater than 255, an
"Illegal function call" error occurs.

Example:

100 ON L-1 GOTO 150,300,320,390

BASIC-80 COMMANDS AND STATEMENTS
2.45

Page 2-56

OPEN

Format:

OPEN <mode>, [#]<file number>,<filename>, [<reclen>]

Version:

Disk

Purpose:

To allow I/O to a disk file.

Remarks:

A disk file must be OPENed before any disk I/O
operation can be performed on that file. OPEN
allocates a buffer for I/O to the file and
determines the mode of access that will be used
with the buffer.
<mode> is a string expression whose
character is one of the following:

first

o

specifies sequential output mode

I

specifies sequential input mode

R

specifies random input/output mode

<file number> is an integer expression whose
value is between one and fifteen. The number is
then associated with the file for as long as it
is OPEN and is used to refer other disk I/O
statements to the file.
<filename> is a string expression containing a
name that conforms to your operating system~s
rules for disk filenames.
<reclen> is an integer expression which, if
included, sets the record length for random
files. The default record length is 128 bytes.
See also page A-3.
NOTE:

A file can be OPENed for sequential input or
random access on more than one file number at a
time. A file may be OPENed for output, however,
on only one file number at a time.

Example:

10 OPEN "I",2,"INVEN"
See also Appendix B.

Page 2-57

BASIC-80 COMMANDS AND STATEMENTS
2.46

OPTION BASE

Format:

OPTION BASE n

where n is 1 or 0
Versions:

8K, Extended, Disk

Purpose:

To declare
subscripts.

RemarkS:

The default base is O.

the

minimum

value

for

array

If the statement

OPTION BASE 1

is executed, the lowest value an array subscript
may have is one.

BASIC-80 COMMANDS AND STATEMENTS
2.47

Page 2-58

OUT

Format:

OUT I,J
where I and J are
range 0 to 255.

integer

expressions

in

the

Versions:

8K, Extended, Disk

Purpose:

To send a byte to a machine output port.

Remarks:

The integer expression I is the port number, and
the integer expression J is the data to be
transmitted.

Example:

100 OUT 32,100

BASIC-80 COMMANDS AND STATEMENTS
2.48

Page 2-59

POKE

Format:

POKE I,J
where I and J are integer expressions

Versions:

8K, Extended, Disk

Purpose:

To write a byte into a memory location.

Remarks:

The integer expression I is the address of the
memory
location to be POKEd.
The integer
expression J is the data to be POKEd. J must be
in the range 0 to 255. In the 8K version, I
must be less than 32768.
In the Extended and
Disk versions, I must be in the range 0 to
65536.
With the 8K version, data may be POKEd into
memory locations above 32768 by supplying a
negative number for I.
The value of I is
computed by subtracting 65536 from the desired
address.
For example, to POKE
data
into
location 45000, I = 45000-65536, or -20536.
The complementary function to POKE is PEEK. The
argument to PEEK is an address from which a byte
is to be read. See Section 3.27.
POKE and PEEK are useful for efficient data
storage, loading assembly language subroutines,
and passing arguments and results to and from
assembly language subroutines.

Example:

10 POKE &H5AOO,&HFF

BASIC-SO COMMANDS AND STATEMENTS
2.49

Page 2-60

PRINT

Format:

PRINT [<list of expressions>]

Versions:

SK, Extended, Disk

Purpose:

To output data at the terminal.

Remarks:

If <list of expressions> is omitted, a blank
line is printed.
If <list of expressions> is
included, the values of the expressions are
printed at the terminal. The expressions in the
list may be numeric and/or string expressions.
(Strings must be enclosed in quotation marks.)
Print Positions
The position of each printed item is determined
by the punctuation used to separate the items in
the list. BASIC-SO divides the line into print
zones of 14 spaces each.
In the list of
expressions, a comma causes the next value to be
printed at the beginning of the next zone. A
semicolon causes the next value to be printed
immediately after the last value. Typing one or
more spaces between expressions has the same
effect as typing a semicolon.
If a comma or a semicolon terminates the list of
expressions, the next PRINT statement begins
printing on the same line, spacing accordingly.
If the list of expressions terminates without a
comma or a semicolon, a carriage return is
printed at the end of the line. If the printed
line is longer than the terminal width, BASIC-SO
goes to the next physical line and continues
printing.
Printed numbers are always followed by a space.
Positive
numbers are preceded by a space.
Negative numbers are preceded by a minus sign.
Single precision numbers that can be represented
with 6 or fewer digits in the unscaled format no
less accurately than they can be represen.ted in
the scaled format, are output using the unscaled
format.
For eX9mple, 10A(-6) is output as
.000001 and 10A(-7) is output as lE-7.
Double
preclslon numbers that can be represented with
16 or fewer digits in the unscaled format no
less accurately than they can be represented in
the scaled format, are output using the unscaled
format.' For example, 10A(-16) is output as
.0000000000000001 and 10A(-17)
is output as
10-17.

BASIC-80 COMMANDS AND STATEMENTS

Page 2-61

A question mark may be used in place of the word
PRINT in a PRINT statement.
Example 1:

10 X=5
20 PRINT X+5, X-5, X*(-5), X""5
30 END
RUN
10
a
-25
Ok

3125

In this example, the commas in the
PRINT
statement cause each value to be printed at the
beginning of the next print zone.
Example 2:

LIST
10 INPUT X
20 PRINT X "SQUARED IS" X""2 "AND" 7
30 PRINT X "CUBED IS" X""3
40 PRINT
50 GOTO 10
Ok
RUN
? 9
9 SQUARED IS 81 AND 9 CUBED IS 729

? 21
21 SQUARED IS 441 AND 21 CUBED IS 9261
?

In this example, the semicolon at the end of
line 20 causes both PRINT statements to be
printed on the same line, and line 40 causes a
blank line to be printed before the next prompt.
Example 3:

10 FOR X = 1 TO 5
20 J=J+5
30 K=K+10
40 ?J7K7
50 NEXT X
Ok
RUN
5 10 10 20 15
Ok

30

20

40

25

50

In this example, the semicolons in the PRINT
statement
cause
each value to be printed
immediately after the preceding value.
(Don~t
forget, a number is always followed by a space
and positive numbers are preceded by a space.)
In line 40, a question mark is used instead of
the word PRINT.

BASIC-80 COMMANDS AND STATEMENTS
2.~0

Page 2-62

PRINT USING
exp>~<list

Format:

PRINT USING <string

of expressions>

Versions:

Extended, Disk

Purpose:

To print strings or numbers
format •.

Remarks
and
Examples:

<list of expressions> is comprised of the string
expressions or numeric expressions that are to
be printed, separated by semicolons.
<string
exp> is a string literal (or variable) comprised
of
special
formatting
ch?lracters.
These
formatting characters (see below) determine the
field and the format of the printed strings or
numbers.

using

a

specified

String Fields
When PRINT USING is used to print strings, one
of three formatting characters may be used to
format the string field:
"!"
"\n spaces\"

Specifies that only the first character
given string is to be printed.

in

the

Specifies that 2+n characters from the string
are to be printed. If the backslashes are typed
with no spaces, two characters will be printed~
with
one
space, three characters will be
printed, and so on. If the string is longer
than
the
field, the extra characters are
ignored. If the field is lonnger than the
string, the string will be left-justified in the
field and padded with spaces on the right.
Example:
10 A$="LOOK":B$="OUT"
30 PRINT USING "!"~A$~B$
40 PRINT USING"\ \"~A$~B$
50 PRINT USING"\
\"~A$~B$~"!!"

RUN
LO
LOOKOUT
LOOK OUT

!!

BASIC-80 COMMANDS AND STATEMENTS
"&"

Page 2-63

Specifies a variable length string field.
When
the field is specified with "&", the string is
output exactly as input. Example:
10 A$="LOOK" :B$="OUT"
20 PRINT USING "!"~A$~
30 PRINT USING "&"~B$
RUN
LOUT
Numeric Fields
When PRINT USING is used to print numbers, the
following special characters may be used to
format the numeric field:

#

A number sign is used to represent each digit
position.
Digit positions are always filled.
If the number to be printed has fewer digits
than positions specified, the number will be
right-justified (preceded by spaces)
in the
field.
A decimal point may be inserted at any position
in the field.
If the format string specifies
that a digit is to precede the decimal point,
the digit will always be printed (as 0 if
necessary). Numbers are rounded as necessary.
PRINT USING
0.78

nit.iin~.78

PRINT USING
987.65

"##i.t#"~987.654

PRINT USING "ii.ii
"~10.2,5.3,66.789,.234
10.20
5.30
66.79
0.23
In the last example, three spaces were inserted
at the end of the format string to separate the
printed values on the line.

+

A plus sign at the beginning or end of the
format string will cause ·the sign of the number
(plus or minus) to be printed before or after
the number.

BASIC-80 COMMANDS AND STATEMENTS

Page 2-64

A minus sign at the end of the format field will
cause negative numbers to be printed with a
trailing minus sign.
PRINT USING "+.....
";-68.95,2.4,55.6,-.9
-68.95
+2.40
+55.60
-0.90
PRINT USING " •••• #";-68.95,22.449,-7.01
68.9522.45
7.01**

A double asterisk at the beginning of the format
string causes leading spaces in the numeric
field to be filled with asterisks. The ** also
specifies positions for two more digits.
PRINT USING "** •• #
";12.39,-0.9,765.1
*12.4
*-0.9
765.1

$$

A double dollar sign causes a dollar sign to be
printed to the immediate left of the formatted
number.
The $$ specifies two
more
digit
positions, one of which is the dollar sign. The
exponential format cannot be used with $$.
Negative numbers cannot be used unless the minus
sign trails to the right.
PRINT USING "$$## •• '.";456.78
$456.78

**$

The **$ at the beginning of a format string
combines the effects of the above two symbols.
Leading spaces will be asterisk-filled and a
dollar sign will be printed before the number.
**$ specifies three more digit positions, one of
which is the dollar sign.
PRINT USING "**$ ••• '.";2.34
***$2.34
A comma that is to the left of the decimal point
in a formatting string causes a comma to be
printed to the left of every third digit to the
left of the decimal point. A comma that is at
the en~ of the format string is printed as part
of the string. A comma specifies another digit
position. The comma has no effect if used with
the exponential (AAAA) format.
PRINT USING " •• '., ••• ";1234.5
1,234.50
PRINT USING " ••••••• ,";1234.5
1234.50,

BASIC-80 COMMANDS AND STATEMENTS

Page 2-65

Four carats (or up-arrows) may be placed after
the
digit
position
characters to specify
exponential format. The four carats allow space
for E+xx to be printed.
Any decimal point
position may be specified.
The significant
digits are left-justified, and the exponent is
adjusted. Unless a leading + or trailing + or is specified, one digit position will be used to
the left of the decimal point to print a space
or a minus sign.
PRINT USING
2.35E+02

"*#.#*~~~~";234.56

PRINT USING
.8889E+06

".####~~~~-";888888

PRINT USING "+.##AAAA";123
+.12E+03

An underscore in the format string causes the
next
character to be output as a literal
character.
PRINT USING "_1##.#*_1 ";12.34
112.341
The literal character
itself
may
be
an
underscore by placing "_" in the format string.
%

If the number to be printed is larger than the
specified numeric field, a percent sign is
printed in front of the number.
If rounding
causes the number to exceed the field, a percent
sign will be printed in front of the rounded
number.
PRINT USING "##.##";111.22
%111.22
PRINT USING ".##";.999
%1.00
If the number of digits specified exceeds 24, an
"Illegal function call" error will result.

BASIC-80 COMMANDS AND STATEMENTS
2.51

Page 2-66

PRINTi AND PRINTi USING

Format:

PRINTt<filenumb~r>,[USING<string

exp>;]<list of exps>

Version:

Disk

Purpose:

To write data to a sequential disk file.

Remarks:

<file number> is the number used when the file
was
OPENed
for
output.
<string. exp> is
comprised of formatting characters as described
in Section 2.50, PRINT USING. The expressions
in <list of expressions>, are the numeric and/or
string expressions that will be written to the
file.
PRINTt does not compress data on the disk.
An
image of the data is written to the disk, just
as it would be displayed on the terminal with a
PRINT statement.
For this reason, care should
be taken to delimit the data on the disk, so
that it will be input correctly from the disk.
In the list of expressions, numeric expressions
should be delimited by semicolons. For example,
PRINTtl,A;B;C;X;Y;Z
(If commas are used as delimiters, the extra
blanks that are inserted between print fields
will also be written to disk.)
String expressions
must
be
separated
by
semicolons in the list. To format the string
expressions correctly on the disk, use explicit
delimiters in the list of expressions.
For example, let A$=nCAMERA n
The statement

and

B$=n93604-1".

PRINTtl,A$;B$
would write CAMERA93604-1 to the disk.
Because
there are no delimiters, this could not be input
as two separate strings.
To
correct
the
problem, insert explicit delimiters into the
PRINTi statement as follows:
PRINTtl,A$;n,";B$
The image written to disk is
CAMERA, 93604-1

BASIC-SO COMMANDS AND STATEMENTS
which can
variables.

be

read

Page 2-67
back

into

string

two

If the strings themselves
contain
commas,
semicolons, significant leading blanks, carriage
returns, or line feeds, write them to disk
surrounded
by
explicit
quotation
marks,
CHR$ (34) •
For example, let A$="CAMERA, AUTOMATIC"
B$="
93604-1". The statement

and

PRINTtl,A$;B$
would write the following image to disk:
CAMERA, AUTOMATIC

93604-1

and the statement
INPUTtl,A$,B$
would
input
"CAMERA"
to
A$
and
"AUTOMATIC
93604-1" to B$. To separate these
strings properly on the disk, write double
quotes to the disk image using CHR$(34}. The
statement
PRINTtl,CHR$(34} ;A$;CHR$(34) ;CHR$(34} ;B$;CHR$(34)
writes the following image to disk:
"CAMERA, AUTOMATIC""

93604-1"

and the statement
INPUTtl,A$,B$
would input "CAMERA, AUTOMATIC"
"
93604-1" to B$.

to

A$

and

The PRINTt statement may also be used with the
USING option to control the format of the disk
file. For example:
PRINTtl,USING"$$ttt.tt,";J;K;L
For more examples using PRINTt, see Appendix B.
See also WRITEt, Section 2.6S.

BASIC-80 COMMANDS AND STATEMENTS
2.52

Page 2-68

PUT

Format:

PUT (#]<file number>(,<record number>]

Version:

Disk

Purpose:

To write a record from
random. disk file.

Remarks:

<file number> is the number under which the file
was OPENed. If <record number> is omitted, the
record will have the next available record
number
(after the last PUT).
The largest
possible record number is 32767.
The smallest
record number is 1.

Example:

See Appendix B.

NOTE:

PRINT#, PRINT# USING, and WRITE# may be used to
put characters in the random file buffer before
a PUT statement.

a

random

buffer

to

a

In the case of WRITE#, BASIC-80 pads the buffer
with spaces up to the carriage return. Any
attempt to read or write past the end of the
buffer causes a "Field overflow" error.

BASIC-80 COMMANDS AND STATEMENTS
2.53

Page 2-69

RANDOMIZE

Format:

RANDOMIZE [<expression>]

Versions:

Extended, Disk

Purpose:

To reseed the random number generator.

Remarks:

If <expression> is
program execution
printing

omitted, BASIC-80 suspends
and asks for a value by

Random Number Seed (-32768 to 32767)?
before executing RANDOMIZE.
If the random number generator is not reseeded,
the RND function returns the same sequence of
random numbers each time the program is RUN. To
change the sequence of random numbers every time
the program is RUN, place a RANDOMIZE statement
at the beginning of the program and change the
argument with each RUN.
Example:

10 RANDOMIZE
20 FOR 1=1 TO 5
30 PRINT RND;
40 NEXT I
RUN
Random Number Seed (-32768
types 3)
.88598 .484668 .586328
Ok
RUN
Random Number Seed (-32768
types 4 for new sequence)
.803506 .162462 .929364
Ok
RUN
Random Number Seed (-32768
sequence as first RUN)
.88598 .484668 .586328
Ok

to 32767)? 3
.119426

(user

.709225

to 32767)? 4 (user
.292443

.322921

to 32767)? 3 (same
.119426

.709225

BASIC-80 COMMANDS AND STATEMENTS
2.54

Page 2-70

READ

Format:

READ <list of variables>

Versions:

8K, Extended, Disk

Purpose:

To read values from a DATA statement and assign
them to variables.
(See DATA, Section 2.10.)

Remarks:

A READ statement must always be
used
in
conjunction
with
a
DATA statement.
READ
statements assign variables to DATA statement
values on a one-to-one basis. READ statement
variables may be numeric or string, and the
values read must agree with the variable types
specified. If they do not agree, a "Syntax
error" will result.
A single READ statement may access one or more
DATA
statements (they will be accessed in
order), or several READ statements may access
the same DATA statment.
If the number of
variables in <list of variables> exceeds the
number of elements in the DATA statement(s), an
OUT OF DATA message is printed. If the number
of variables specified is fewer than the number
of elements in the DATA statement(s), subsequent
READ statements will begin reading data at the
first unread element.
If
there
are
no
subsequent READ statements, the extra data is
ignored.
To reread DATA statements from the start, use
the RESTORE statement (see RESTORE, Section
2.57)

Example 1:
80 FOR I=l TO 10
90 READ A(I)
100 NEXT I
110 DATA 3.08,5.19,3.12,3.98,4.24
120 DATA 5.08,5.55,4.00,3.16,3.37

This program segment READs the values from the
After
DATA
statements
into the array A.
execution, the value of A(l) will be 3. 08, and
so on.

BASIC-80 COMMANDS AND STATEMENTS
Example 2:

Page 2-71

LIST
10 PRINT "CITY", "STATE", " ZIP"
20 READ C$,S$,Z
30 DATA "DENVER,", COLORADO, 80211
40 PRINT C$,S$,Z
Ok

RUN
CITY
DENVER,

STATE
COLORADO

ZIP
80211

Ok

This program READs string and numeric data
the DATA statement in line 30.

from

BASIC-80 COMMANDS AND STATEMENTS
2.55

Page 2-72

REM

Format:

REM <remark>

Versions:

8K, Extended, Disk

Purpose:

To allow explanatory remarks to be inserted in a
program.

Remarks:

REM statements are not executed but are output
exactly as entered when the program is listed.
REM statements may be branched into (from a GOTO
or GOSUB statement), and execution will continue
with the first executable statement after the
REM statement.
In the Extended and Disk versions, remarks may
be added to the end of a line by preceding the
remark with a single quotation mark instead of
: REM.

Example:

..

120 REM CALCULATE AVERAGE VELOCITY
130 FOR I=1 TO 20
140 SUM=SUM + V(I)

or, with Extended and Disk versions:

120 FOR I=l TO 20
130 SUM=SUM+V(I)
140 NEXT I

~CALCULATE

AVERAGE VELOCITY

BASIC-80 COMMANDS AND STATEMENTS
2.56

Page 2-73

RENUM

Format:

RENUM [[<new number>] [,[<old number>] [,<increment>]]]

Versions:

Extended, Disk

Purpose:

To renumber program lines.

Remarks:

<new number> is the first line number to be used
in the new sequence. The default is 10. <old
number> is the line in the current program where
renumbering is to begin.
The default is the
first line of the program. <increment> is the
increment to be used in the new sequence. The
default is 10.
RENUM also changes all line number references
following
GOTO,
GOSUB,
THEN,
ON ••• GOTO,
ON ••• GOSUB and ERL statements to reflect the new
line numbers.
If a nonexistent line number
appears after one of these statements, the error
message "Undefined line xxxxx in yyyyy" is
printed. The incorrect line number reference
(xxxxx) is not changed by RENUM, but line number
yyyyy may be changed.

NOTE:

RENUM cannot be used to change the order of
program lines (for example, RENUM 15,30 when the
program has three lines numbered 10, 20 and 30)
or to create line numbers greater than 65529.
An "Illegal function call" error will result.

Examples:

RENUM

Renumbers the entire program.
The first new line number
will be 10. Lines will
increment by 10.

RENUM 300,,50

Renumbers the entire program. The first new line
number will be 300. Lines
will increment by 50.

RENUM 1000,900,20

Renumbers the lines from
900 up so they start with
line number 1000 and
increment by 20.

BASIC-80 COMMANDS AND STATEMENTS
2 • 57

Page 2-74

RESTORE

Format:

RESTORE [<line number>]

Versions:

8K, Extended, Disk

Purpose:

To allow DATA statements to
specified line.

Remarks:

After a RESTORE statement is executed, the next
READ statement accesses the first item in the
first DATA statement in the program.
If <line
number> is specified, the next READ statement
accesses the first item in the specified DATA
statement.

Example:

10 READ A,B,C
20 RESTORE
30 READ D,E,F
40 DATA 57, 68, 79

be

reread

from

a

BASIC-80 COMMANDS AND STATEMENTS
2.58

Page 2-75

RESUME

Formats:

RESUME
RESUME a
RESUME NEXT
RESUME <line number>

Versions:

Extended, Disk

Purpose:

To continue program execution after an
recovery procedure has been performed.

Remarks:

Anyone of the four formats shown above may
used, depending upon where execution is
resume:

error
be
to

RESUME
or
RESUME a

Execution resumes at the
statement which caused the
error.

RESUME NEXT

Execution resumes at the
statement immediately following the one which
caused the error.

RESUME <line number> Execution resumes at
<line number>.
A RESUME statement that is not in an error trap
routine causes a "RESUME without error" message
to be pr inted.
.
Example:

10 ON ERROR GOTO 900
•

900 IF (ERR=230) AND (ERL=90) THEN PRINT "TRY
AGAIN":RESUME 80

BASIC-SO COMMANDS AND STATEMENTS
2.59

Page 2-76

-RUN

Format 1:

RUN [<line number>]

Versions:

SK, Extended, Disk

Purpose:

To execute the program currently in memory.

Remarks:

If <line number> is specified, execution begins
on that line.
Otherwise, execution begins at
the lowest line number. BASIC-SO always returns
to command level after a RUN is executed.

Example:

RUN

Format 2:

RUN <filename>[,R]

Version:

Disk

Purpose:

To load a file from disk into memory and run it.

Remarks:

<filename> is the name used when the file was
SAVEd.
(With CP/M and ISIS-II, the default
extension .BAS is supplied.)
RUN closes all open files and deletes the
current contents of memory before loading the
nR n
However, with the
designated program.
option, all data files remain OPEN.

Example:

RUN nNEWFILn, R
See also Appendix B.

BASIC-SO COMMANDS AND STATEMENTS
2.60

Page 2-77

SAVE

I ,P]

Format:

SAVE <filename> [,A

Version:

Disk

Purpose:

To save a program file on disk.

Remarks:

<filename> is a quoted string that conforms to
your
operating
system"'s
requirements
for
filenames.
(With CP/M, the default extension
.BAS is supplied.) If <filename> already exists,
the file will be written over.
Use the A option to save the file in ASCII
format.
Otherwise, BASIC saves the file in a
compressed binary format.
ASCII format takes
more space on the disk, but some disk access
requires that files be in ASCII format.
For
instance, the MERGE command requires and ASCII
format file, and some operating system commands
such as LIST may require an ASCII format file.
Use the P option to protect the file by saving
it
in
an encoded binary format.
When a
protected file is later RUN (or LOADed), any
attempt to list or edit it will fail.

Examples:

SAVE nCOM2 n ,A
SAVEnpRoo n , P
See also Appendix B.

BASIC-80 COMMANDS AND STATEMENTS
2.61

Page 2-78

STOP

Format:

STOP

Versions:

8K, Extended, Disk

Purpose:

To terminate program
command level.

Remarks:

STOP statements may be used anywhere in a
program to terminate execution. When a STOP is
encountered, the following message is printed:

execution

and

return

to

Break in line nnnnn
Unlike the END statement,
does not close files.

the

STOP

statement

BASIC-80 always returns to command level after a
STOP is executed.
Execution is resumed by
issuing a CONT command (see Section 2.8).
Example:

10 INPUT A,B,C
20 K=AA2*5.3:L=B A3/.26
30 STOP
40 M=C*K+100:PRINT M
RON
? 1,2,3
BREAK IN 30
Ok
PRINT L
30.7692
Ok
CONT
115.9
Ok

BASIC-SO COMMANDS AND STATEMENTS
2.62

Page 2-79

SWAP

Format:

SWAP <variab1e>,<variab1e>

Versions:

EXtended, Disk

Purpose:

To exchange the values of two variables.

Remarks:

Any type variable may be SWAPped (integer,
single precision, dQub1e precision, string), but
the two variables must be of the same type or a
"Type mismatch" error results.

Example:

LIST
10 A$=" ONE " : B$=" ALL " : C$="FOR"
20 PRINT A$ C$ B$
30 SWAP A$, B$
40 PRINT A$ C$ B$
RUN

Ok
ONE FOR ALL
ALL FOR ONE
Ok

BASIC-80 COMMANDS AND STATEMENTS
2.63

Page 2-80

TRON/TROFF

Format:

TRON
TROFF

Versions:

Extended, Disk

Purpose:

To trace the execution of program statements.

Remarks:

As an aid in debugging, the TRON statement
(executed in either the direct or indirect mode)
enables a trace flag that prints each line
number of the program as it is executed. The
numbers appear enclosed in square brackets. The
trace flag is disabled with the TROFF statement
(or when a NEW command is executed).

Example:

TRON
Ok
LIST
10 K=lO
20 FOR J=l TO 2
30 L=K + 10
40 PRINT J~K~L
50 K=K+lO
60 NEXT
70 END
Ok
RUN

[10] [20] [30] [40] 1
[50] [60] [30] [40] 2
[50] [60] [70]
Ok
TROFF
Ok

10
20

20
30

BASIC-80 COMMANDS AND STATEMENTS
2.64

Page 2-81

WAIT

Format:

WAIT <port number>, • I[,J]
where I and J are integer expressions

Versions:

8K, Extended, Disk

Purpose:

To suspend program execution while
the status of a machine input port.

Remarks:

The WAIT statement causes execution to
be
suspended until a specified machine input port
develops a specified bit pattern. The data read
at the port is exclusive OR~ed with the integer
expression J, and then AND~ed with 1.
If the
result is zero, BASIC-80 loops back and reads
the data at the port again. If the result is
nonzero,
execution continues with the next
statement. If J is omitted, it is assumed to be
zero

CAUTION:

It is possible to enter an infinite loop with
the WAIT statement, in which case it will be
necessary to manually restart the machine.

Example:

100 WAIT 32,2

monitoring

BASIC-80 COMMANDS AND STATEMENTS
2.65

Page 2-82

WHILE ••• WEND

Format:

WHILE <expression>
[<loop statements>]
WEND

Versions:

Extended, Disk

Purpose:

To execute a series of statements in a
long as a given condition is true.

Remarks:

If <expression> is not zero (Le., true), <loop
statements>
are
executed
until
the WEND
statement is encountered. BASIC then returns to
the WHILE statement and checks <expression>. If
it is still true, the process is repeated.
If
it is not true, execution resumes with the
statement following the WEND statement.

loop

as

WHILE/WEND loops may be nested to any level.
Each WEND will match the most recent WHILE. An
unmatched WHILE statement causes
a
nWHILE
without WEND n error, and an unmatched WEND
statement causes a nWEND without WHILE n error,.
Example:

90~BUBBLE SORT ARRAY A$
100 FLIPS=l ~FORCE ONE PASS TaRU LOOP
110 WHILE FLIPS
115
FLIPS=O
120
FOR I=l TO J-l
IF A$(I»A$(I+l) THEN
130
SWAP A$(I) ,A$(I+l) :FLIPS=l
140
NEXT I
150 WEND

BASIC-80 COMMANDS AND STATEMENTS
2.66

Page 2-83

WIDTH

Format:

WIDTH [LPRINT] <integer expression>

Versions:

Extended, Disk

Purpose:

To set the printed line width in number
characters for the terminal or line printer.

Remarks:

If the LPRINT option is omitted, the line width
is set at the terminal. If LPRINT is included,
the line width is set at the line printer.

of

<integer expression> must have a value in the
range 15 to 255.
The default width is 72
characters.
If <integer expression> is 255, the line width
is "infinite," that is, BASIC never inserts a
carriage return. However, the position of the
cursor or the print head, as given by the POS or
LPOS function, returns to zero after position
255.
Example:

10 PRINT "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

RUN
ABCDEFGHIJKLMNOPQRSTUVWXYZ
Ok
WIDTH 18
Ok

RUN
ABCDEFGHIJKLMNOPQR
STUVWXYZ
Ok

BASIC-SO COMMANDS AND STATEMENTS
2.67

Page 2-S4

WRITE

Format:

WRITE[<list of expressions»

Ver~ion:

Disk

Purpose:

To output data at the terminal.

Remark$.:

If <list of expressions> is omitted, a blank
line is output.
If <list of expressions> is
included, the values of te expressions are
output at thee terminal. The expressions in the
list may be numeric and/or string expressions,
and they mu~t be separated by commas.
When the printed items are output, each item
will be separated from the last by a comma.
Printed strings will be delimited by quotation
marks.
After the last item in the list is
printed, BASIC inserts a carriage return/line
feed.
WRITE output~ numeric values using the same
format as the PRINT statement, Section 2.49.

Example:

10 A:;SO:B=90:C$="THAT'-S ALL"
20 WRITE A,B,C$
RUN

SO,
Ok

90,"THAT~S

ALL"

BASIC-80 COMMANDS AND STATEMENTS
2.68

Page 2-85

WRITEi

Format:

WRITEi<fi1e number>,<list of expressions>

Version:

Disk

Purpose:

To write data to a sequential file.

Remarks:

<file number> is the number under which the file
was OPENed in "0" mode. The expressions in the
list are string or numeric expressions, and they
must be separated by commas.
The difference between WRITEi and PRINTi is that
WRITEi inserts commas between the the items as
they are written to disk and delimits strings
with quotation marks.
Therefore, it is not
necessary for the
user
to
put
explicit
delimiters in the list. A carriage return/line
feed sequence is inserted after the last item in
the list is written to disk.

Example:

Let
A$="CAMERA"
statement:

and

B$="93604-1".

The

WRITEi1,A$,B$
writes the following image to disk:
"CAMERA", "93604-1"
A subsequent INPUTi statement, such as:
INPUTi1,A$,B$
would input "CAMERA" to A$ and "93604-1" to BS.

Paae 3-1

CHAPTER 3
BASIC-80 FUNCTIONS

The intrinsic functions provided by BASIC-80 are presented
in this chapter.
The functions may be called from any
program without further definition.
Arguments to functions are always enclosed in parentheses.
In the formats given for the functions in this chapter, the
arguments have been abbreviated as follows:
X and Y

Represent any numeric expressions

I and J

Represent integer expressions

X$ and Y$

Represent string expressions

If a floating point value is supplied where an integer is
required, BASIC-80 will round the fractional portion and use
the resulting integer.
NOTE
With the BASIC-80 and BASIC-86
interpreters, only integer and
single precision resullts are
returned by funtions.
Double
precision
functions
are
supported only by the BASIC
compiler.

BASIC-80 FUNCTIONS
3.1

Page 3-2

ABS

Format:

ASS (X)

Versions:

8K, Extended, Disk

Action:

Returns the absolute value of the expression X.

Example:

PRINT ABS(7*(-5»
35
Ok

3.2

ASC

Format:

ASC (X$)

Versions:

8K, Extended, Disk

Action:

Returns a numerical value that is the ASCII code
of the first character of the string X$.
(See
Appendix M for ASCII codes.) If X$ is null, an
"Illegal function call" error is returned.

Example:

10 X$ = "TEST"
20 PRINT ASC (X$)
RUN
84

Ok
See the CHR$
conversion.

function

for

ASClI-to-string

BASIC-SO FUNCTIONS
3.3

Page 3-3

ATN

Format:

ATN(X)

Versions:

SK, Extended, Disk

Action:

Returns the arctangent of X in radians.
Result
is in the range -pi/2 to pi/2. The expression X
may be any numeric type, but the evaluation of
ATN is always performed in single precision.

Example:

10 INPUT X
20 PRINT ATN (X)
RUN
? 3
1.24905
Ok

3.4

COBL

Format:

COBL(X)

Versions:

Extended, Disk

Action:

Converts X to a double precision number.

Example:

10 A = 454.67
20 PRINT A:COBL(A)
RUN
454.67 454.6700134277344
Ok

BASIC-80 FUNCTIONS
3.5

Page 3-4

CRR$

Format:

CHR$(I)

Versions:

8K, Extended, Disk

Action:

Returns a string whose one element has ASCII
code I.
(ASCII codes are listed in Appendix M.)
CHR$ is commonly used to send
a
special
character to the terminal. For instance, the
BEL character could be sent (CHR$(7»
as a
preface to an error message, or a form feed
could be sent (CRR$(12»
to clear a CRT screen
and return the cursor to the home position.

Example:

PRINT CHR$ (66)
B

Ok
See the ASC
conversion.

3.6

function

for

ASClI-to-numeric

CINT

Format:

CINT(X)

Versions:

Extended, Disk

Action:

Converts X to an integer by rounding
the
fractional portion.
If X is not in the range
-32768 to 32767, an "Overflow" error occurs.

Example:

PRINT CINT(45.67)
46
Ok
See the CDBL and CSNG functions for converting
numbers to the double precision and single
precision data type. See also the FIX and INT
functions, both of which return integers.

BASIC-SO FUNCTIONS
3.7

Page 3-5

COS

Format:

COS (X)

Versions:

SK, Extended, Disk

Action:

Returns the cosine of X in radians.
The
calculation of COS (X)
is performed in single
precision.

Example:

10 X = 2 *COS ( .4)
20 PRINT X
RUN
1.S42l2
Ok

3.S

CSNG

Format:

CSNG (X)

Versions:

Extended, Disk

Action:

Converts X to a single precision number.

Example:

10 Ai = 975.3421#
20 PRINT A#; CSNG{Ai)
RUN
975.3421 975.342
Ok
See the CINT and CDBL functions for converting
numbers to the integer and double precision data
types.

BASIC-80 FUNCTIONS
3.9

Page 3-6

CVI, CVS, CVD

Format:

CVI«2-byte string»
CVS«4-byte string»
CVD«8-byte string»

Version:

Disk

Action:

Convert string values
to
numeric
values.
Numeric values that are read in from a random
disk file must be converted from strings back
into numbers.
CVI converts a 2-byte string to
an integer. CVS converts a 4-byte string to a
single precision number. CVD converts an 8-byte
string to a double precision number.

Example:
70 FIELD #1,4 AS N$, 12 AS B$, •••
80 GET #1
90 Y=CVS (N$)

See also MKI$r
Appendix B.

3.10

MKS$,

MKD$,

Section

3.25

and

EOF

Format:

EOF«file number»

Version:

Disk

Action:

Returns -1 (true) if the end of a sequential
file has been reached.
Use EOF to test for
end-of-file while INPUTting,
to avoid "Input
past end" errors.

Example:

10 OPEN "I",l,"DATA"
20 C=O
30 IF EOF(l) THEN 100
40 INPUT #l,M(C)
50 C=C+l:GOTO 30

BASIC-80 FUNCTIONS
3.11

Page 3-7

~

Format:

EXP(X)

Versions:

8K, Extended, Disk

Action:

Returns e to the power of X.
X must be
<=87.3365.
If EXP overflows, the "Overflown
error message is displayed, machine infinity
with the appropriate sign is supplied as the
result, and execution continues.

Example:

10 X = 5
20 PRINT EXP (X-I)
RUN
54.5982
Ok

3.12

-FIX

Format:

FIX (X)

Versions:

Extended, Disk

Action:

Returns the truncated integer part of X. FIX(X)
is equivalent to SGN(X)*INT(ABS(X». The major
difference between FIX and INT is that FIX does
not return the next lower number for negative X.

Examples:

PRINT FIX(58.75)
58
Ok
PRINT FIX(-58.75)
-58
Ok

BASIC-80 FUNCTIONS
3.13

Page 3-8

FRE

Format:

FRE(O)
FRE (X$)

Versions:

8K, Extended, Disk

Action:

Arguments to FRE are dummy arguments.
FRE
returns the number of bytes in memory not being
used by BASIC-80.
FRE("") forGes a garbage collection
before
returning
the
number
of free bytes.
BE
PATIENT: garbage collection may take 1 to 1-1/2
minutes.
BASIC
will not initiate garbage
collection until all free memory has been used
up.
Therefore, using FRE("") periodically will
result in shorter delays for each
garbage
collection.

Example:

3.14

PRINT FRE(O)
14542
Ok

HEX$

Format:

HEX$ (X)

Versionsr

Extended, Disk

Action:

Returns
a
string
which
represents
the
hexadecimal value of the decimal argument. X is
rounded to an integer
before
HEX$(X)
is
evaluated.

Example:

10 INPUT X
20 A$ = HEX$ (X)
30 PRINT X "DECIMAL IS II A$ " HEXADECIMAL II
RUN
? 32
32 DECIMAL IS 20 HEXADECIMAL
Ok
See the OCT$ function for octal conversion.

BASIC-80 FUNCTIONS
3.15

Page 3-9

INKEY$

Format:

INKEY$

Action:

Returns either a one-character string cont~ining
a character read from the terminal or a null
string if no character is pending at
the
terminal.
No characters will be echoed and all
characters are passed through tto the program
except
for Contro1-C, which terminates the
program.
(With the BASIC Compiler, Contro1-C is
also passed through to the program.)

Example:

1000 ~TlMED INPUT SUBROUTINE
1010 RESPONSE$=""
1020 FOR I%=l TO TIMELIMIT%
1030 A$=INKEY$ : IF LEN(A$)=O THEN 1060
1040 IF ASC(A$)=13 THEN TIMEOUT%=O : RETURN
1050 RESPONSE$=RESPONSE$+A$
1060 NEXT I%
1070 TIMEOUT%=l : RETURN

3.16

INP

Format:

INP (I)

Versions:

8K, Extended, Disk

Action:

Returns the byte read from port I.
I must be in
the range 0 to 255. INP is the complementary
function to the OUT statement, Section 2.47.

Example:

100 A=INP(255)

BASIC-SO FUNCTIONS
3.17

Page 3-10

INPUT$

Format:

INPUT$(X[,[#]Y])

Version:

Disk

Action:

Returns a string of X characters, read from the
terminal or from file number Y. If the terminal
is used for input, no characters will be echoed
and all control characters are passed through
except Control-C, which is used to interrupt the
execution of the INPUT$ function.

Example 1:

5 ~LIST THE CONTENTS OF A SEQUENTIAL FILE IN
HEXADECIMAL
10 OPEN"I",l,"DATA"
20 IF EOF(l) THEN 50
30 PRINT HEX$(ASC(INPUT$(l,#l»);
40 GOTO 20
50 PRINT
60 END

Example 2:
•

100 PRINT "TYPE P TO PROCEED OR S TO STOP"
110 X$=INPUT$(l)
120 IF X$="P" THEN 500
130 IF X$="S" THEN 700 ELSE 100

BASIC-80 FUNCTIONS
3.18

Page 3-11

INSTR

Format:

INSTR ( [I, ] X$, Y$)

Versions:

Extended, Disk

Action:

Searches for the first occurrence of string Y$
in X$ and returns the position at which the
match is found.
Optional offset I sets the
position for starting the search.
I must be in
the range 1 to 255.
If I>LEN(X$) or if X$ is
null or if Y$ cannot be found, INSTR returns O.
If Y$ is null, INSTR returns I or 1. X$ and Y$
may be string variables, string expressions or
string literals.

Example:

10 X$ = "ABCDEB"
20 Y$ = "B"
30 PRINT INSTR(X$,Y$) ;INSTR(4,X$,Y$)

RUN
2 6
Ok
NOTE:

If I=O is specified, error message "ILLEGAL
ARGUMENT IN <line number>" will be returned.

BASIC-80 FUNCTIONS
3.19

Page 3-12

INT

Format:

INT (X)

Versions,:

8K, Extended, Disk

Action:

Returns the largest integer <=X.

Examples:

PRINT INT ( 99. 89)
99
Ok
PRINT INT(-12.ll}
-13
Ok
See the FIX and CINT functions which also return
integer values.

3.20

LEFT$

Format:

LEFT$ (X$, I)

Versions:

8K, Extended, Disk

Action:

Returns a string comprised of the leftmost I
characters of X$. I must be in the range 0 to
255. If I is greater than LEN (X$), the. entire
string (X$) will be returned. If I=O, the null
string (length zero) is returned.

Example:

10 A$ = "BASIC-80"
20 B$ = LEFT$(A$,5}
30 PRINT B$
BASIC
Ok
Also see the MID$ and RIGHT$ functions.

BASIC-80 FUNCTIONS
3.21

Page 3-13

LEN

Format:

LEN (X$)

Versions:

8R, Extended, Disk

Action:

Returns the number of
characters
in
X$.
Non-printing characters and blanks are counted.

Example:

10 X$ = "PORTLAND, OREGON"
20 PRINT LEN (X$)
16
Ok

3.22

LOC

Format:

LOC«file number»

Version:

Disk

Action:

With random disk files, LOC returns the next
record number to be used if a GET or PUT
(without a record number)
is executed.
With
sequential files, LOC returns the number of
sectors (128 byte blocks) read from or written
to the file since it was OPENed.

Example:

200 IF LOC(l) >50 THEN STOP

BASIC-80 FUNCTIONS
3.23

LOG

Format:

LOG (X)

Versions:

8K, Extended, Disk

Action:

Returns the-natural logarithm of X.
greater than zero.

Example:

PRINT LOG ( 45/7 )
1.86075
Ok

3.24

Page 3-14

X must

be

LPOS

Format:

LPOS(X)

Versions:

Extended, Disk

Action:

Returns the current position of the line printer
print head within the line printer buffer. Does
not necessarily give the physical position of
the print head. X is a dummy argument.

Example:

100 IF LPOS(X) >60 THEN LPRINT CHR$(13)

BASIC-80 FUNCTIONS
3.25

Page 3-15

MID$

Format:

MID$ (X$, I [ ,J] )

Versions:

8K, Extended, Disk

Action:

Returns a string of length J characters from X$
beginning with the Ith character. I and J must
be in the range 1 to 255. If J is omitted or if
there are fewer than J characters to the right
of the Ith character, all rightmost characters
beginning with the Ith character are returned.
If I>LEN(X$), MID$ returns a null string.

Example:

LIST
10 A$=nGOOD n
20 B$=nMORNING EVENING AFTERNOON"
30 PRINT A$;MID$(B$,9,7)
Ok
RUN
GOOD EVENING
Ok
Also see the LEFT$ and RIGHT$ functions.

NOTE:

3.26

If I=O is specified, error message "ILLEGAL
ARGUMENT IN <line number>" will be returned.

MKI$, MKS$, MKD$

Format:

MKI$«integer expression»
MKS$«single precision expression»
MKD$«double precision expression»

Version:

Disk

Action:

Convert numeric values to string values.
Any
numeric value that is plac'ed in a random file
buffer with an LSET or RSET statement must be
converted to a string. MKI$ converts an integer
to a 2-byte string.
MKS$ converts a single
precision number to a 4-byte string.
MKD$
converts a double precision number to an 8-byte
string.

Example:

90 AMT= (K+T)
100 FIELD #1, 8 AS D$, 20 AS N$
110 LSET D$ = MKS$(AMT)
120 LSET N$ = A$
130 PUT #1

See also CVI, CVS, CVD, Section 3.9 and Appendix
B.

BASIC-SO FUNCTIONS
3.27

Page 3-16
OCT$

Format:

OCT$ (X)

Versions:

Extended, Disk

Action:

Returns a string which represents the octal
value of the decimal argument. X is rounded to
an integer before OCT$(X) is evaluated.

Example:

PRINT OCT$ (24)
30
Ok
See
the
HEX $
conversion.

3.2S

function

for

hexadecimal

PEEK

Format:

PEEK (I)

Versions:

SK, Extended, Disk

Action:

Returns the byte (decimal integer in the range a
to 255)
read from memory location I. With the
SK version of BASIC-SO, I must be less than
3276S.
To PEEK at a memory location above
3276S, subtract 65536 from the desired address.
With Extended and Disk BASIC-SO, I must be in
the range a to 65536. PEEK is the complementary
function to the POKE statement, Section 2.4S.

Example:

A=PEEK (&H5AOO)

BASIC-80 FUNCTIONS
3.29

Page 3-17

POS

Format:

POS (I)

Versions:

8K, Extended, Disk

Action:

Returns the current cursor
position.
The
leftmost position is 1. X is a dummy argument.

Example:

IF POS(X) >60 THEN PRINT CHR$(13)
Also see the LPOS function.

3.30

RIGHT$

Format:

RIGHT$(X$,I)

Versions:

8K, Extended, Disk

Action:

Returns the rightmost I characters of string X$.
If I=LEN{X$), returns X$.
If I=O, the null
string (length zero) is returned.

Example:

10 A$="DISK BASIC-80"
20 PRINT RIGHT$(A$,8)

RUN
BASIC-80
Ok
Also see the MID$ and LEFT$ functions.

BASIC-SO FUNCTIONS
3.31

Page 3-1S

RND

Format:

RND [ (X) ]

Versions:

SK, Extended, Disk

Action:

Returns a random number between 0 and 1.
The
same sequence of random numbers is generated
each time the program is RUN unless the random
number generator is reseeded
(see RANDOMIZE,
Section 2.53). However, X<O always restarts the
same sequence for any given X.
X>O or X omitted generates the next random
number in the sequence. x=o repeats the last
number generated.

Example:

3.32

10 FOR I=l TO 5
20 PRINT INT(RND*100);
30 NEXT
RUN
24 30 31 51 5
Ok

SGN

Format:

SGN(X)

Versions:

SK, Extended, Disk

Action: .

If X>O, SGN(X) returns 1.
If X=O, SGN(X) returns O.
If X<O, SGN(X) returns -1.

Example:

ON SGN(X)+2 GOTO 100,200,300 branches to 100 if
X is negative, 200 if X is 0 and 300 if X is
positive.

BASIC-80 FUNCTIONS
3.33

Page 3-19

SIN

Format:

SIN(X)

Versions:

8K, Extended, Disk

Action:

Returns the sine of X in radians.
single
calculated
in
COS(X)=SIN(X+3.l4l59/2) •

Example:

PRINT SIN(1.5)
.997495
Ok

3.34

SIN (X)
is
precision.

SPACES

Format:

SPACE$(X)

Versions:

Extended, Disk

Action:

Returns a string of spaces of length X.
The
expression X is rounded to an integer and must
be in the range 0 to 255.

Example:

10 FOR I = 1 TO 5
20 X$ = SPACE$(I)
30 PRINT X$;I
40 NEXT I
RUN

1
2

3
4

5

Ok
Also see the SPC function.

BASIC-80 FUNCTIONS
3.35

Page 3-20

SPC

Format:

SPC (I)

Versions:

8K, Extended, Disk

Action:

Prints I blanks on the terminal. SPC may only
be used with PRINT and LPRINT statements.
I
must be in the range 0 to 255.

Example:

PRINT "OVER" SPC(15) "THERE"
OVER
~ERE
Ok
Also see the SPACE$ function.

3.36

SQR

Format:

SQR(X)

Versions:

8K, Extended, Disk

Action:

Returns the square root of X.

Example:

10 FOR X = 10 TO 25 STEP 5
20 PRINT X, SQR(X)
30 NEXT

RUN
10
15
20
25
Ok

3.16228
3.87298
4.47214
5

X must be >=0.

BASIC-80 FUNCTIONS
3.37

Page 3-21

STR$

Format:

STR$(X)

Versions:

8K, Extended, Disk

Action:

Returns a string representation of the value
X.

Example:

5 REM ARITHMETIC FOR KIDS
10 INPUT "TYPE A NUMBER";N
20 ON LEN(STR$(N» GOSUB 30,100,200,300,400,500

of

Also see the VAL function.

3.38

STRING$

Formats:

STRING$(I,J)
STRING$(I,X$)

Versions:

Extended, Disk-

Action:

Returns a string of length I whose characters
all have ASCII code J or the first character of
X$.

Example:

10 X$ = STRING$(10,45)
20 PRINT X$ "MONTHLY REPORT" X$
RUN
----------MONTHLY REPORT---------Ok

BASIC-80 FUNCTIONS
3.39

Page 3-22

TAB

Format:

TAB (I)

Versions:

8K, Extended, Disk

Action:

Spaces to position I on the terminal.
If the
current print position is already beyond space
I, TAB goes to that position on the next line.
Space 1 is the leftmost position, and the
rightmost position is the width minus one.
I
must be in the range 1 to 255. TAB may only be
used in PRINT and LPRINT statements.

Example:

10 PRINT "NAME" TAB (25) "AMOUNT" : PRINT
20 READ A$ ,B$
30 PRINT A$ TAB (25) B$
40 DATA "G. T. JONES","$25.00"
RUN
NAME
AMOUNT

G. T. JONES

$25.00

Ok

3.40

TAN

Format:

TAN (X)

Versions:

8K, Extended, Disk

Action:

Returns the tangent of X in radians. TAN (X)
is
calculated
in
single
preclslon.
If TAN
overflows,
the "Overflow" error message
is
displayed, machine infinity with the appropriate
sign is supplied as the . result, and execution
continues.

Example:

10 Y = Q*TAN(X)/2

BASIC-80 FUNCTIONS
3.41

Page 3-23

USR

Format :

USR[<digit>] (X)

Versions:

8K, Extended, Disk

Action:

Calls the user's assembly language subroutine
with the argument X. <digit> is allowed in the
Extended and Disk versions only. <digit> is in
the range 0 to 9 and corresponds to the digit
supplied with the DEF USR statement for that
routine.
If
<digit> is omitted, USRO is
assumed. See Appendix x.

Example:

40 B = T*SIN (Y)
50 C = USR (B/2)
60 D = USR(B/3)

3.42

VAL

Format:

VAL (X$)

Versions:

8K, Extended, Disk

Action:

Returns the numerical value of string X$.
The
VAL function also strips leading blanks, tabs,
and linefeeds from the argument string.
For
example,
VAL (" -3)
returns -3.

Example:

10 READ NAME$,CITY$,STATE$,ZIP$
20 IF VAL(ZIP$) <90000 OR VAL(ZIP$) >96699 THEN
PRINT NAME$ TAB(25) "OUT OF STATE"
30 IF VAL(ZIP$) >=90801 AND VAL(ZIP$) <=90815 THEN
PRINT NAME$ TAB(25) "LONG BEACH"

See the STR$
conversion.

function

for

numeric

to

string

BASIC-80 FUNCTIONS
3.43

Page 3-24

VARPTR

Format 1:

VARPTR«variable name»

Versions:

Extended, Disk

Format 2:

VARPTR(t<file number»

Version:

Disk

Action:

Format 1: Returns the address of the first byte
of data identified with <variable name>. A
value must be assigned to <variable name> prior
to execution of VARPTR. Otherwise an "Illegal
function call" error results. Any type variable
name may be used (numeric, string, array), and
the address returned will be an integer in the
range 32767 to -32768. If a negative address is
returned, add it to 65536 to obtain the actual
address.
VARPTR is usually used to obtain the address of
a variable or array so it may be passed to an
assembly language subroutine. A function call
of the form VARPTR(A(O»
is usually specified
when
passing
an
array,
so
that
the
lowest-addressed
element
of
the array is
returned.

NOTE:

All simple variables should be assigned before
calling
VARPTR
for an array, because the
addresses of the arrays change whenever a new
simple variable is assigned.
Format 2: For sequential files,
returns the
starting address of the disk I/O buffer assigned
to <file number>. For random fles, returns the
address of the FIELD buffer assigned to <file
number>.
In Standalone Disk BASIC, VARPTR(t<file number»
returns the first byte of the file block. See
Appendix H.

Example:

100 X=USR(VARPTR(Y»

Page A-l

APPENDIX A
New Features in BASIC-SO, Release 5.0

The execution of BASIC programs written under Microsoft
BASIC, release 4.51 and earlier may be affected by some of
the new features in release 5.0. Before attempting to run
such programs, check for the following:
1.

New reserved words: CALL, CHAIN, COMMON,
WEND, WRITE, OPTION BASE, RANDOMIZE.

WHILE,

2.

Conversion from floating point to integer values
results in rounding, as opposed to truncation.
This affects not only assignment statements (e.g.,
I%=2.5 results in I%=3) , but also affects function
and stat~ment evaluations (e.g., TAB(4.5) goes to
the 5th position, A(1.5) yeilds A(2), and X=11.5
MOD 4 yields 0 for X).

3.

The body of a FOR ••• NEXT loop is skipped if the
initial value of the loop times the sign of the
step exceeds the final value times the sign of the
step. See Section 2.22.

4.

Division by zero and overflow no longer
fatal errors. See Section 1.S.1.2.

5.

The RND function has been changed so that RND with
no argument is the same as RND with a positive
argument. The RND function generates the same
sequence of random numbers with each RUN, unless
RANDOMIZE is used. See Sections 2.53 and 3.31.

6.

The rules for PRINTing single preclslon and double
precision numbers have been changed. See Section
2.49.

7.

String space is allocated dynamically, and the
first argument in a two-argument CLEAR statement
sets the end of memory. The second argument sets
the amount of stack space. See Section 2.4.

produce

Page A-2
8.

Responding to INPUT with too many or too few items,
or with non-numeric characters instead of digits,
causes the message "?Redo from start" to
be
printed.
If a single variable is requested, a
carriage return may be entered to indicate the
default values of 0 for numeric input or null for
string input. However, if more than one variable
is requested, entering a carriage return will cause
the "?Redo from start" message to be printed
because too few items were entered. No assignment
of input values is made until an
acceptable
response is given.

9.

There are two new field formatting characters for
use with PRINT USING.
An ampersand is used for
variable length string fields, and an underscore
signifies a literal character in a format string.

10.

If the expression supplied with the WIDTH statement
is 255, BASIC uses an "infinite" line width, that
is, it does not insert carriage returns.
WIDTH
LPRINT may be used to set the line width at the
line printer. See Section 2.66.

11.

The at-sign and underscore are no
editing characters.

12.

Variable names are significant up to 40 characters
and can contain embedded reserved words. However,
reserved words must now be delimited by spaces. To
maintain compatibility with earlier versions of
BASIC, spaces will be
automatically
inserted
between
adjoining reserved words and variable
names.
WARNING: This insertion of spaces may
cause the end of a line to be truncated if the line
length is close to 255 characters.

13.

BASIC programs may be saved in a
format.
See SAVE, Section 2.60.

longer

protected

used

as

binary

Page B-1

APPENDIX B
BASIC-80 Disk I/O

Disk I/O procedures for the beginning BASIC-80 user are
examined in this appendix. If you are new to BASIC-80 or if
you~re getting
disk related errors, read through these
procedures and program examples to make sure you~re using
all the disk statements correctly.
Wherever a filename is required in a disk command or
statement, use a name that conforms to your operating
system~s requirements for
filenames.
The CP/M operating
system will append a default extension .BAS to the filename
given in a SAVE, RUN, MERGE or LOAD command.

B.l

PROGRAM FILE COMMANDS

Here is a review of the commands
program file manipulation.

and

statements

used

in

SAVE' <filename> [,A]

Writes to disk the program that is
currently
residing
in
memory.
Optional A writes the program as a
series
of
ASCII
characters.
(Otherwise, BASIC uses a compressed
binary format.)

LOAD <filename>[,R]

Loads the program from disk
into
memory.
Optional R runs the program
immediately. LOAD always deletes the
current contents of memory and closes
all files before LOADing.
If R is
included, however, open data files are
kept open.
Thus programs can
be
chained or loaded in sections and
access the same data files.

Page B-2
RUN <filename>[,R]

RUN <filename> loads the program from
disk into memory and runs it. RUN
deletes the current contents of memory
and closes all files before loading
the program.
If the R option is
included, however, all open data files
are kept open.

MERGE <filename>

Loads the program from disk
into
memory but does not delete the current
contents of memory. The program line
numbers on disk are merged with the
line numbers in memory.
If two lines
have the same number, only the line
from the disk program is saved. After
a MERGE command, the "merged" 'progr am
resides in memory, and BASIC returns
to command level.

KILL <filename>

Deletes the file from
the
disk.
<filename> may be a program file, or a
sequential or random access data file.

NAME <old filename>
AS<new filename>

To change the name of a disk file,
execute the NAME
statement,
NAME
<oldfile> AS <newfile>. NAME may be
used with program files, random files,
or sequential files.

B.2

PROTECTED FILES

If you wish to save a program in an encoded binary format,
use the "Protect" option with the SAVE command.
For
example:
SAVE "MYPROG",P
A program saved this way cannot be listed or edited.
You
may also want to save an unprotected copy of the program for
listing and editing purposes.

B.3

DISK DATA FILES ~ SEQUENTIAL AND RANDOM I/O

There are two types of disk data files that may be created
and accessed by a BASIC-80 program: sequential files and
random access files.

Page B-3
B.3.l

Sequential Files

Sequential files are easier to create than random files but
are limited in flexibility and speed when it comes to
accessing the data.
The data that is written to
a
sequential
file
is
stored,
one item after another
(sequentially), in the order it is sent and is read back in
the same way.
The statements and functions that are used
files are:
OPEN

PRINTi
PRINTt USING

CLOSE

EOF

INPUTt
LINE INPUTI

with

sequential

WRITEt

LOC

The following program steps are required to
sequential file and access the data in the file:

create

1.

OPEN the file in "0" mode.

OPEN "0", 11, "DATA"

2.

Write data to the file
using the PRINTI statement.
(WRITEt may be used instead.)

PRINTil,A$;B$;C$

3.

To access the data in the
file, you must CLOSE the file
and reOPEN it in "I" mode.

CLOSE 11
OPEN "I", 11, "DATA"

4.

Use theINPUTt statement to
read data from the sequential
file into the program.

INPUTI1,X$,Y$,Z$

a

Program B-1 is a short program that creates a sequential
file, "DATA", from information you input at the terminal.

Page B-4
10 OPEN "0", *1, "DATA"
20 INPUT "NAME";N$
25 IF N$="DONE" THEN END
30 INPUT "DEPARTMENT";D$
40 INPUT "DATE HIRED";H$
50 PRINT*1,N$;",";D$1","1H$
60 PRINT:GOTO 20
RUN
NAME? MICKEY MOUSE
DEPARTMENT? AUDIO/VISUAL AIDS
DATE HIRED? 01/12/72
NAME? SHERLOCK HOLMES
DEPARTMENT? RESEARCH
DATE HIRED? 12/03/65
NAME? EBENEEZER SCROOGE
DEPARTMENT? ACCOUNTING
DATE HIRED? 04/27/78
NAME? SUPER MANN
DEPARTMENT? MAINTENANCE
DATE HIRED? 08/16/78
NAME? etc.
PROGRAM B-1 - CREATE A SEQUENTIAL DATA FILE

Page B-5
Now look at Program B-2. It accesses the file "DATA" that
was created in Program B-1 and displays the name of everyone
hir~d in 1978.

10 OPEN "I",tl,"DATA"
20 INPUTtl,N$,D$,H$
30 IF RIGHT$(H$,2)="78" THEN PRINT N$
40 GOTO 20
R~

EBENEEZER SCROOGE
SUPER MANN
Input past end in 20
Ok
PROGRAM B-2 - ACCESSING A SEQUENTIAL FILE

Program B-2 reads, sequentially, every item in the file.
When all the data has been read, line 20 causes an "Input
past end" error. To avoid getting this error, insert line
15 which uses the EOF function to test for end-of-file:
15 IF EOF(l) THEN END
and change line 40 to GOTO 15.
A program that creates a sequential file can also write
formatted data to the disk with the PRINTt USING statement.
For example, the statement
PRINTtl,USING"tttt.tt,";A,B,C,D
could be used to write numeric data to disk without explicit
delimiters.
The comma at the end of the format string
serves to separate the items in the disk file.
The LOC function, when used with a sequential file, returns
the number of sectors that have been written to or read from
the file since it was OPENed. A sector is a l28-byte block
of data.

B.3.l.l Adding ~ To A Sequential File If you have a sequential file residing on disk and later
want to add more data to the end of it, you cannot simply
open the file in "0" mode and start writing data.
As soon
as you open a sequential file in "0" mode, you destroy its
current contents. The following procedure can be used to
add data to an existing file called "NAMES".

Page B-6
1.

OPEN "NAMES" in "I" mode.

2.

OPEN a second file called "COPY" in "0" mode.

3.

Read in the data in "NAMES" and write it to "COPY".

4.

CLOSE "NAMES" and KILL it.

5.

Write the new information to "COPY".

6.

Rename "COPY" as "NAMES" and CLOSE.

7.

Now there is a file on disk called "NAMES" that
includes all the previous data plus the new data
you just added.

Program B-3 illustrates this technique. It can be used to
create or add onto a file called NAMES. This program also
illustrates the use of LINE INPUT# to read strings with
embedded commas from the disk file. Remember, LINE INPUT#
will read in characters from the disk until it sees a
carriage return (it does not stop at quotes or commas) or
until it has read 255 characters.

Page B-7
10 ON ERROR GOTO 2000
20 OPEN "I",tl,"NAMES"
30 REM IF FILE EXISTS, WRITE IT TO "COPY"
40 OPEN "O",t2,"COPY"
SO IF EOF(l) THEN 90
60 LINE INPUTtl,A$
70 PRINTt2,A$
80 GOTO SO
90 CLOSE #1
100 KILL "NAMES"
110 REM ADD NEW ENTRIES TO FILE
120 INPUT "NAME";N$
130 IF N$="" THEN 200 ~CARRIAGE RETURN EXITS INPUT LOOP
140 LINE INPUT "ADDRESS? ";A$
150 LINE INPUT "BIRTHDAY? ";B$
160 PRINTt2,N$
170 PRINTt2,A$
180 PRINT#2,B$
190 PRINT:GOTO 120
200 CLOSE
205 REM CHANGE FILENAME BACK TO "NAMES"
210 NAME "COPY" AS "NAMES"
2000 IF ERR=53 AND ERL=20 THEN OPEN "O",#2,"COPY":RESUME 120
2010 ON ERROR GOTO 0
PROGRAM B-3 - ADDING DATA TO A SEQUENTIAL FILE

The error trapping routine in line 2000 traps a "File does
If this happens, the
not
exist" error in line 20.
statements that copy the file are skipped, and "COPY" is
created as if it were a new file.

B.3.2

Random Files

Creating and accessing random files requires more program
steps than sequential files,
but there are advantages to
using random files. One advantage is that random files
require less room on the disk, because BASIC stores them in
a packed binary format.
(A sequential file is stored as a
series of ASCII characters.)
The biggest advantage to random files is that data can be
accessed randomly,
i.e., anywhere on the disk -- it is not
necessary to read through all the information, as with
sequential files. This is possible because the information
is stored and accessed in distinct units called records and
each record is numbered.
The statements and functions that are used with random files
are:

page B-8
OPEN

FIELD

LSET/RSET

PUT

CLOSE

Loe

MI<I$
MKS$
MKD$

CVI
CVS
CVD

GET

B.3.2.l Creating A Random File The following program steps-are required to create a
file.

random

1.

OPEN "R",il,"FILE",32
OPEN the file for random
access ("R" mode). This example
specifies a record length of 32
bytes. If the record length is
omitted, the default is 128
bytes.

2.

Use the FIELD statement to
allocate space in the random
buffer for the variables that
will be written to the random
file.

3.

Use LSET to move the data
LSET N$=X$
into the random buffer.
LSET A$=MKS$(AMT)
Numeric values must be made
LSET P$=TEL$
into strings when placed in
the buffer. To do this, use the
"make" functions: MKI$ to
make an integer value into a
string, MKS$ for a single
precision value, and MKD$ for
a double precision value.

4.

Write the data from
the buffer to the disk
using the PUT statement.

FIELD il 20 AS N$,
'4 AS A$, 8 AS P$

PUT il,CODE%

Look at Program B-4. It takes information that is input at
the terminal and writes it to a random file. Each time the
PUT statement is executed, a record is written to the file.
The two-digit code that is input in line 30 becomes the
record number.

Page B-9

NOTE
Do not use a FIELDed string
variable in an INPUT or LET
statement.
This causes the
pointer for that variable to
point
into
string
space
instead of the random file
buffer.

10 OPEN "R",ll,"FILE",32
20 FIELD 11,20 AS N$, 4 AS A$, 8 AS p$
30 INPUT "2-DIGIT CODE"1CODE%
40 INPUT nNAME"1X$
50 INPUT "AMOUNT";AMT
60 INPUT "PHONE";TEL$:PRINT
70 LSET N$=X$
80 LSET A$=MKS$(AMT)
90 LSET P$=TEL$
100 PUT Il,CODE%
110 GOTO 30
PROGRAM B-4 - CREATE A RANDOM FILE

B.3.2.2 Access A Random File The following program steps are required to access a
file:

random

1.

OPEN the file in "R" mode.

OPEN "R",ll,"FILE",32

2.

Use the FIELD statement to
allocate space in the random
buffer for the variables that
will be read from the file.

FIELD 11 20 AS N$,
4 AS A$, 8 AS p$

NOTE:
In a program that performs both
input and output on the same random
file, you can often use just one
OPEN statement and one FIELD
statement.

Page B-10
3.

Use the GET statement to move
the desired record into the
random buffer.

GET il,CODE%

4.

The data in the buffer ma'y
now be accessed by the program.
Numeric values must be converted
back to numbers using the
"convert" functions: CVI for
integers, CVS for single
precision values, and CVD
for double precision values.

PRINT N$
PRINT CVS (A$)

Program B-5 accesses the random file "FILE" that was created
in Program B-4.
By inputting the three-digit code at the
terminal, the information associated with that code is read
from the file and displayed.

10 OPEN "R",il,"FILE",32
20 FIELD iI, 20 AS N$, 4 AS A$, 8 AS p$
30 INPUT "2-DIGIT CODE"1CODE%
40 GET tl, CODE%
50 PRINT N$
60 PRINT USING· "$$tti.ii"1CVS(A$)
70 PRINT P$:PRINT
.
80 GOTO 30
PROGRAM B-5 - ACCESS A RANDOM FILE
The LOC function, with random files, returns the "current
record number." The current record number is one plus the
last record number that was used in a GET or PUT statement.
For example, the statement
IF LOC(l) >50 THEN END
ends program execution if
filetl is higher than 50.

the

current

record

number

in

Program B-6 is an inventory program that illustrates random
file access. In this program, the record number is used as
the part number, and it is assumed the inventory will
contain no more than 100 different part numbers. Lines
900-960 initialize the data file by writing CHR$(255) as the
first character of each record. This is used later (line
270 and line 500) to determine whether an entry already
exists for that part number.
Lines 130-220 display the different inventory functions that
the program performs. When you type in the desired function
number, line 230 branches to the appropriate subroutine.

Page B-11
120 OPEN"R",#1,"INVEN.DAT",39
125 FIELD#l,l AS F$,30 AS D$, 2 AS Q$,2 AS R$,4 AS P$
130 PRINT:PRINT "FUNCTIONS:":PRINT
135 PRINT 1,"INITIALIZE FILE"
140 PRINT 2,"CREATE A NEW ENTRY"
150 PRINT 3,"DISPLAY INVENTORY FOR ONE PART"
160 PRINT 4,"ADD TO STOCK"
170 PRINT 5,"SUBTRACT FROM STOCK"
180 PRINT 6, "DISPLAY ALL ITEMS BELOW REORDER LEVEL"
220 PRINT:PRINT:INPUT"FUNCTION";FUNCTION
225 IF (FUNCTION<l) OR (FUNCTION>6) THEN PRINT
"BAD FUNCTION NUMBER":GO TO 130
230 ON FUNCTION GOSUB 900,250,390,480,560,680
240 GOTO 220
250 REM BUILD NEW ENTRY
260 GOSUB 840
270 IF ASC(F$) <>255 THEN INPUT"OVERWRITE";A$:
IF A$<>"Y" THEN RETURN
280 LSET F$=CHR$(O)
290 INPUT "DESCRIPTION";DESC$
300 LSET D$=DESC$
310 INPUT "QUANTITY IN STOCK";Q%
320 LSET Q$=MKI$(Q%)
330 INPUT "REORDER LEVEL";R%
340 LSET R$=MKI$(R%)
350 INPUT "UNIT PRICE";P
360 LSET P$=MKS$(P)
370 POT#l,PART%
380 RETURN
390 REM DISPLAY ENTRY
400 GOSUB 840
410 IF ASC(F$) =255 THEN PRINT "NULL ENTRY." : RETURN
420 PRINT USING "PART NUMBER iii";PART%
430 PRINT 0$
440 PRINT USING "QUANTITY ON HAND #i#ii";CVI(Q$)
450 PRINT USING "REORDER LEVEL iiiii";CVI(R$)
460 PRINT USING "UNIT PRICE $$i#.ii";CVS(P$)
470 RETURN
480 REM ADD TO STOCK
490 GOSUB 840
500 IF ASC(F$) =255 THEN PRINT "NULL ENTRY":RETURN
510 PRINT D$:INPUT "QUANTITY TO ADD ":A%
520 Q%=CVI(Q$)+A%
530 LSET Q$=MKI$(Q%)
540 PUTi1,PART%
550 RETURN
560 REM REMOVE FROM STOCK
570 GOSUB 840
580 IF ASC(F$)=255 THEN PRINT "NULL ENTRY":RETURN
590 PRINT 0$
600 INPUT "QUANTITY TO SUBTRACT";S%
610 Q%=CVI(Q$)
620 IF (Q%-S%)<O THEN PRINT "ONLY";Q%;" IN STOCK":GOTO 600
630 Q%=Q%-S%

Page B-12
640 IF Q%=<CVI(R$) THEN PRINT "QUANTITY NOW":Q%:
" REORDER LEVEL":CVI(R$)
650 LSET Q$=MKI$(Q%)
660 PUTt1,PART%
670 RETURN
680 DISPLAY ITEMS BELOW REORDER LEVEL
690 FOR 1=1 TO 100
710 GETt1,I
720 IF CVI(Q$) <CVI(R$) THEN PRINT 0$:" QUANTITY":
CVI(Q$) TAB (50) "REORDER LEVEL":CVI(R$)
730 NEXT I
740 RETURN
840 INPUT "PART NUMBER":PART%
850 IF (PART%<l) OR(PART%>100) THEN PRINT "BAD PART .NUMBER":
GOTO 840 ELSE GETt1,PART%:RETURN
890 END
900 REM INITIALIZE FILE
910 INPUT "ARE YOU SURE":B$:IF B$<>"Y" THEN RETURN
920 LSET F$=CHR$(255)
930 FOR 1=1 TO 100
940 PUTt1,I
950 NEXT I
960 RETURN
PROGRAM B-6 - INVENTORY

Page C-l

APPENDIX C
Assembly Language Subroutines

All versions of BASIC-80 have prov~s~ons for interfacing
with assembly language subroutines. The OSR function allows
assembly language subroutines to be called in the same way
BASIC~s intrinsic functions are called.
NOTE
The addresses of the DEINT,
GIVABF,
MAKINT
and FRCINT
routines
are
stored
in
locations
that
must
be
supplied
individually
for
different implementations of
BASIC.

C.l

MEMORY ALLOCATION

Memory space must be set aside for an assembly language
subroutine before it can be loaded. During initialization,
enter the highest memory location minus the amount of memory
needed for the assembly language subroutine(s). BASIC uses
all memory available from its starting location up, so only
the topmost locations in memory can be set aside for user
subroutines.
When an assembly language subroutine is called, the stack
pointer is set up for 8 levels (16 bytes) of stack storage.
If more stack space is needed, BASIC~s stack can be saved
and a new stack set up for use by the assembly language
subroutine. BASIC~s stack must be restored, however, before
returning from the subroutine.

Page C-2
The assembly language subroutine may be loaded into memory
by means of the system monitor, or the BASIC POKE statement,
or (if the user has the MACRO-80 or FORTRAN-80 package)
routines may be assembled with MACRO-80 and loaded using
LINK-80.

C.2

USR FUNCTION CALLS - 8K BASIC

The starting address of the assembly language subroutine
must be stored in USRLOC, a two-byte location in memory that
is supplied individually with different implementations of
BASIC-80.
With 8K BASIC, the starting address may be POKEd
into USRLOC. Store the low order byte first, followed by
the high order byte.
The function USR will call the routine whose address is in
USRLOC.
Initially USRLOC contains the address of ILLFUN,
the routine that gives the "Illegal function call" error.
Therefore, if USR is called without changing the address in
USRLOC, an "Illegal function call" error results.
The format of a USR function call is
USR (argument)
where the argument is a numeric expression. To obtain the
argument, the assembly language subroutine must call the
routine DEINT. DEINT places the argument into the D,E
register pair as a 2-byte, 2~s complement integer.
(If the
argument is not in the range -32768 to 32767, an "Illegal
function call" error occurs.)
To pass the result back from
an
assembly
language
subroutine, load the value in register pair [A,B], and call
the routine GIVABF.
If GIVABF is not called, USR(X) returns
X.
To return to BASIC, the assembly language subroutine
must execute a RET instruction.
For example, here is an assembly
mUltiplies the argument by 2:
USRSUB: CALL DEINT
XCHG
DAD H

MOV A,H
MOV B,L
JMP GIVABF

language

subroutine

that

;put arg in D,E
;move arg to H, L
;H,L=H,L+H,L
;move result to A,B
;pass result back and RETurn

Note that valid results will be obtained from this routine
for arguments in the range -16384<=x<=16383. The single
instruction JMP GIVABF has the same effect as:

Page C-3
CALL GIVABF
RET

To return additional values to the program, load
memory and read them with the PEEK function.

them

into

There are several methods by which a program may call more
than one USR routine. For example, the starting address of
each routine may be POKEd into USRLOC prior to each USR
call, or the argument to USR could be an index into a table
of USR routines.

USR FUNCTION CALLS - EXTENDED !!Q DISK BASIC

C.3

In the Extended and Disk versions, the
function is

format

of

the

USR

USR[<digit>] (argument)
where DIGIT> is from 0 to 9 and the argument is any numeric
or string expression. <digit> specifies which USR routine
is being called, and corresponds with the digit supplied in
the DEF USR statement for that routine. If <digit> is
omitted, USRO is assumed. The address given in the DEF USR
statement determines the starting address of the subroutine.
When the USR function call is made, register A contains a
value that specifies the type of argument that was given.
The value in A may be one of the following:
Value in A

~

of Argument

2

Two-byte integer

3

String

4

Single precision floating point number

8

Double precision floating point number

(two~s

complement)

If the argument is a number, the [H,L] register pair points
to the Floating Point Accumulator (FAC) where the argument
is stored.
If the argument is an integer:
FAC-3 contains the lower 8 bits of the argument and
FAC-2 contains the upper 8 bits of the argument.
If the argument is a single precision floating point number:
FAC-3, contains the lowest 8 bits of mantissa and

Page C-4
FAC-2 contains the middle 8 bits of mantissa and
FAC-l contains the highest 7 bits of mantissa
with leading 1 suppressed (implied). Bit 7 is
the sign of the number (O=positive, l=negative).
FAC is the exponent minus 128, and the binary
point is to the left of the most significant
bit of the mantissa.
If the argument is a double precision floating point number:
FAC-7 through FAC-4 contain four more bytes
of mantissa (FAC-7 contains the lowest 8 bits).
If the argument is a string, the [D,E] register pair points
to 3 bytes called the nstring descriptor. n Byte 0 of the
string descriptor contains the length of the string (0 to
255) •
Bytes 1 and 2, respectively, are the lower and upper
8 bits of the string starting address in string space.
CAUTION: If the argument is a string literal in the
program, the string descriptor will point to program text.
Be careful not to alter or destroy your program this way.
To avoid unpredictable results, add +"n to the string
literal in the program. Example:
A$ = nBASIC-80 n+ nn
This will copy the strin~ literal into string space and will
prevent alteration of program text during a subroutine call.
Usually, the value returned by a USR function is the same
type (integer, string, single precision or double precision)
as the argument that was passed to it. However, calling the
MAKINT . routine returns the integer in [H,L] as the value of
the function, forcing the value returned by the function to
be integer.
To execute MAKINT, use the following sequence
to return from the subroutine:
PUSH
LHLD
XTHL

H

xxx

RET

;save value to be returned
;get address of MAKINT routine
;save return on stack and
;get back [H,L]
;return

Also, the argument of the function, regardless of its type,
may be forced to an integer by calling the FRCINT routine to
get the integer value of the argument in [H,L]. Execute the
following routine:
LXI

H

PUSH
LHLD
PCHL
SUBl:

H
xxx

.....

;get address of subroutine
;continuation
;place on stack
;get address of FRCINT

Page C-S
C.4

CALL STATEMENT

Extended and Disk BASIC-80 user function calls may also be
made with the CALL statement. The calling sequence used is
the same as that in Microsoft's FORTRAN, COBOL and BASIC
compilers.
A CALL statement with no arguments generates a simple "CALL"
instruction. The corresponding subroutine should return via
a simple "RET." (CALL and RET are 8080 opcodes - see an 8080
reference manual for details.)
A subroutine CALL with arguments results in a somewhat more
complex calling sequence.
For each argument in the CALL
argument list, a parameter is passed to the subroutine.
That parameter is the address of the low byte of the
argument. Therefore, parameters always occupy two bytes
each, regardless of type.
The method of passing the parameters depends upon the number
of parameters to pass:
1.

If the number of parameters is less than or equal
to 3, they are passed in the registers. Parameter
1 will be in HL, 2 in DE (if present), and 3 in BC
(if present).

2.

If the number of parameters is greater than 3, they
are passed as follows:
1.

Parameter 1 in HL.

2.

Parameter 2 in DE.

3.

Parameters 3 through n in a contiguous data
block.
BC will point to the low byte of this
data block (i.e., to the low byte of parameter
3) •

Note that, with this scheme, the subroutine must know how
many
parameters
to
expect
in order to find them.
Conversely, the calling program is responsible for passing
the correct number of parameters. There are no checks for
the correct number or type of parameters.
If the subroutine expects more than 3 parameters, and needs
to transfer them to a local data area, there is a system
subroutine which will perform this transfer. This argument
transfer routine is named $AT (located in the FORTRAN
library, FORLIB.REL), and is called with HL pointing to the
local data area, BC pointing to the third parameter, and A
containing the number of arguments to transfer
(i.e., the
total number of arguments minus 2).
The subroutine is

Page C-6
responsible for saving the first two parameters before
calling $AT.
For example, if a subroutine expects 5
parameters, it should look like:
SUBR: SHLD
XCHG
SHLD
MVI
LXI
CALL

PI

iSAVE PARAMETER 1

P2
A,3
H,P3
$AT

iSAVE PARAMETER 2
iNO. OF PARAMETERS LEFT
iPOINTER TO LOCAL AREA
iTRANSFER THE OTHER 3 PARAMETERS

.[Body of subroutine]
PI:
P2:
P3:

RET
DS
DS
DS

i RETURN TO CALLER

2

iSPACE FOR PARAMETER 1
iSPACE FOR PARAMETER 2
iSPACE FOR PARAMETERS 3-5

2
6

A listing of the argument transfer routine $AT follows.
00100
00200
00300
00400
00500
00600
00700
00800
00900
01000
01100
01200
01300
01400
01500
01600
01700
01800
01900
02000
02100
02200
02300

.,
i [B, C]
i [H, L]
i [A]

$AT:
ATl:

ARGUMENT TRANSFER
POINTS TO 3RD PARAM.
POINTS TO LOCAL STORAGE FOR PARAM 3
CONTAINS THE t OF PARAMS TO XFER (TOTAL-2)
ENTRY
XCHG
MOV
MOV
MOV
INX
MOV
INX
XCHG
MOV
INX
MOV
INX
XCHG
DCR
JNZ
RET

$AT
iSAVE [H,L] IN [D,E]
H,B
L,C
C,M
H
B,M
H
M,C
H
M,B
H
A
ATI

i [H,L]

= PTR TO PARAMS

i[B,C]
i [H,L]

= PARAM ADR
POINTS TO LOCAL STORAGE

iSTORE PARAM IN LOCAL AREA
iSINCE GOING BACK TO ATI
iTRANSFERRED ALL PARAMS?
iNO, COPY MORE
i YES, RETURN

Page C-7
When accessing parameters in a subroutine, don~t forget that
they are pointers to the actual arguments passed.
NOTE
It is entirely up to
the
programmer to see to it that
the arguments in the calling
program match in number, ~,
and length with the parameters
expected by the subroutine.
This
applies
to
BASIC
subroutines, as well as those
written in assembly language.

C. 5

INTERRUPTS

Assembly language subroutines can be written to handle
interrupts. All interrupt handling routines should save the
stack, register A-L and the PSW. Interrupts should always
be re-enabled before returning from the subroutine., since
an interrupt automatically disables all further interrupts
once it is received.
The user should be aware of which
interrupt vectors are free in the particular version of
BASIC that has been supplied.
(Note to CP/M users: In CP/M
BASIC, all interrupt vectors are free.)

Page D-l

APPENDIX D
BASIC-~O

with the CP/M Operating System

The CP/M version of BASIC-80
(MBASIC)
is supplied on a
standard size 3740 single density diskette. The name of the
file is MBASIC.COM.
(A 28K or larger CP/M system is
recommended. )
To run MBASIC, bring up CP/M and type the following:
A>MBASIC <carriage return>
The system will reply:
xxxx Bytes Free
BASIC-80 Version 5.0
(CP/M Version)
Copyright 1978 (C) by Microsoft
Created: dd-mmm-yy
Ok
MBASIC is the same as Disk BASIC-80 as
manual, with the following exceptions:

D.l

described

in

this

INITIALIZATION

The initialization dialog has been replaced by a set of
options which are placed after the MBASIC command to CP/M.
The format of the command line is:
A>MBASIC [<filename>] [/F:<number of files>] [/M:<highest memory location>]
[/S:<maximum record size>]
If <filename> is present, MBASIC proceeds as if a RUN
<filename>
command were typed after initialization is
complete. A default extension of .BAS is used if none is
supplied and the filename is less than 9 characters long.
This allows BASIC programs to be executed in batch mode
using the SUBMIT facility of CP/M. Such programs should
include a SYSTEM statement (see below)
to return to CP/M
when they have finished, allowing the next program in the

Page 0-2
batch stream to execute.
If /F:<number of files> is present, it sets the number of
disk data files that may be open at anyone time during the
execution of a BASIC program.
Each file data
block
allocated in this fashion requires 166 bytes of memory.
If
the /F option is omitted, the number of files defaults to 3.
The /M:<highest memory location> option sets the highest
memory location that will be used by MBASIC.
In some cases
it is desirable to set the amount of memory well below the
CP/M~s
FOOS
to
reserve space for assembly language
subroutines. In all cases, <highest memory location> should
be below the start of FOOS . (whose address is contained in
locations 6 and 7). If the 1M option is omitted, all memory
up to the start of FOOS is used.
/S:<maximum record size> may be added at the end of the
command line to set the maximum record size for use with
random files. The default record size is 128 bytes.
NOTE
<number of files>, <highest
memory location>, and <maximum
record size> are numbers that
may be either decimal, octal
(preceded
by
&0)
or
hexadecimal (preceded by &H) •
Examples:
A>MBASIC PAYROLL. BAS

Use all memory and 3 files,
load and execute PAYROLL. BAS.

A>MBASIC INVENT/F:6

Use all memory and 6 files,
load and execute INVENT. BAS.

A>MBASIC /M:32768

Use first 32K of memory and
3 files.

A>MBASIC OATACK/F:2/M:&H9000
Use first 36K of memory, 2
files, and execute OATACK.BAS.

0.2

DISK FILES

Disk filenames follow the normal CP/M naming conventions.
All filenames may include A:
or B:
as the first two
characters to specify a disk drive, otherwise the currently
selected drive is assumed. A default extension of .BAS is

Page D-3
used on LOAD, SAVE, MERGE and RUN <filename> commands if no
"." appears in the filename and the filename is less than 9
characters long.
For systems with CP/M 2.x, large random files are supported.
The maximum logical record number is 32767. If a record
size of 256 is specified, then files up to 8 megabytes can
be accessed.

D.3

FILES COMMAND

Format:

FILES[<filename>]

Purpose:

To print the names
current disk.

Remarks:

If <filename> is omitted, all the files on the
currently
selected
drive
will be listed.
<filename> is a string formula which may contain
question marks (?) to match any character in the
filename or extension. An asterisk (*)
as the
first character of the filename or extension
will match any file or any extension.

Examples:

FILES
FILES "*.BAS"
FILES "B:*.*"
FILES "TEST?BAS"

D.4

of

files

residing

on

the

RESET COMMAND

Format:

RESET

Purpose:

To close all disk files and write the directory
information to a diskette before it is removed
,from a disk drive.

Remarks:

Always execute a RESET command before removing a
diskette from a disk drive. Otherwise, when the
diskette is used again, it will not have the
current directory information written on the
directory track.
all drives and
RES~T closes all open files on
writes the directory track to every diskette
with open files.

Page 0-4
0.5

LOF FUNCTION

Format:

LOF«file number»

Action:

Returns the number of records present in the
last extent read or written. If the file does
not exceed one extent (128 records), then LOF
returns the true length of the file.

Example:

110 IF NUM%>LOF(~} THEN PRINT "INVALID ENTRY"

0.6

EOF

With CP/M, the EOF function may be used with random files.
If a GET is done past the end of file, EOF will return -1.
This may be used to find the size of a file using a binary
~earch or other algorithm.

0.7

MISCELLANEOUS
1.

CSAVE and CLOAD are not implemented.

2.

To return to CP/M, use the SYSTEM command or
statement.
SYSTEM closes all files and then
performs a CP/M warm start.
Control-C always
returns to MBASIC, not to CP/M.

3.

FRCINT is at 103 hex and MAKINT is at 105 hex.
(Add 1000 hex for ADDS versions, 4000 for SBC CP/M
versions.)

Page E-1

APPENDIX E
Converting Programs to BASIC-80

If you have programs written in a BASIC other than BASIC-80,
some minor adjustments may be necessary before running them
with BASIC-80. Here are some specific things to look for
when converting BASIC programs.
E.1

STRING DIMENSIONS

Delete all statements that are used to declare the length of
strings.
A statement such as DIM A$(I,J), which dimensions
a string array for J elements of length I, should be
converted to the BASIC-80 statement DIM A$(J).
Some BASICs use a
comma
or
ampersand
for
string
concatenation.
Each of these must be changed to a plus
sign, which
is
the
operator
for
BASIC-80
string
concatenation.
In BASIC-80, the MID$, RIGHT$, and LEFT$ functions are used
Forms such as A$(I) to
to take substrings of strings.
to take a
access the Ith character in A$, or A$(I,J)
substring of A$ from position I to position J, must be
changed as follows:
Other BASIC
X$=A$ (I)
X$=A$(I,J)

BASIC-80
X$=MID$ (A$, 1,1)
X$=MID$(A$,I,J-I+l)

If the substring reference is on the left side of an
assignment and X$ is used to replace characters in A$,
convert as follows:
Other BASIC

8K BASIC-80

A$(I)=X$
A$(I,J)=X$

A$=LEFT$ (A$,I-l) +X$+MID$(A$,I+l)
A$=LEFT$(A$,I-l) ;X$;MID$(A$,J+l)
Ext. and Disk BASIC-80
------

A$(I)=X$
A$(I,J9=X$

MID$(A$,l,l)=X$
MID$(A$,I,J-I+l)=X$

Page E-2
E.2

MULTIPLE ASSIGNMENTS

Some BASICs allow statements of the form:
10 LET B=C=O
to set Band C equal to zero. BASIC-80 would interpret the
second equal sign as a logical operator and set B equal to
-1 if C equaled O. Instead, convert this statement to two
assignment statements:
10 C=O:B=O

E.3

MULTIPLE STATEMENTS

Some BASICs use a backs1ash (\)
to separate multiple
statements on a line. With BASIC-80, be sure all statements
on a line are separated by a colon (:).

E.4

MAT FUNCTIONS

Programs using the MAT functions available in some BASICs
must
be
rewritten using FOR ••• NEXT loops to execute
properly.

Page F-l

APPENDIX F
Summary of Error Codes and Error Messages

Code

Number

NF

1

Message
NEXT without FOR
A variable in a NEXT statement
correspond
to
any
previously
unmatched FOR statement variable.

does not
executed,

SN

2

Syntax error
A line is encountered that contains some
incorrect sequence of characters (such as
unmatched parenthesis, misspelled command or
statement, incorrect punctuation, etc.).

RG

3

Return without GOSUB
A RETURN statement is encountered for
there
is
no
previous, unmatched
statement.

which
GOSUB

OD

4

Out of data
A READ statement is executed when there are
no DATA statements with unread data remaining
in the program.

FC

5

Illegal function call
A parameter that is out of range is passed to
a math or string function. An FC error may
also occur as the result of:

1.

a
negative
subscript

2.

a negative or zero argument with LOG

3.

a negative argument to SQR

4.

a negative mantissa
exponent

or

unreasonably

with

a

large

non-integer

Page F-2

5.

a call to a USR function for which the
starting address has not yet been given

6.

an improper argument to MID$, LEFT$,
RIGHT$,
INP, OUT, WAIT, PEEK, POKE, TAB,
SPC,
STRING$,
SPACES,
INSTR,
or
ON ••• GOTO.

OV

6

OVerflow
The result of a calculation is too large to
be represented in BASIC-80"'s n,umber format.
If underflow occurs, the result is zero and
execution continues without an error.

OM

7

Out of memory
A program is too large, has too many FOR
loops or GOSUBs, too many variables, or
expressions that are too complicated.

UL

8

Undefined line
A line
reference
in
a
GOTO,
IF ••• THEN ••• ELSE
or
DELETE
is
nonexistent line.

GOSUB,
to
a

BS

9

Subscript out of range
An array element is referenced either with a
subscript that is outside the dimensions of
the array, or with the wrong number of
subscripts.

DD

10

Redimensioned array
Two DIM statements are given for the same
array, or a DIM statement is given for an
array after the default dimension of 10 has
been established for that array.

/0

11

Division by zero
A division by zero is encountered in an
expression, or the operation of involution
results in zero being rai.sed to a negative
power. Machine infinity with the sign of the
numerator is supplied as the result of the
division, or positive machine infinity is
supplied as the result of the involution, and
execution continues.

ID

12

Illegal direct
A statement that is illegal in direct mode is
entered as a direct mode command.

TM

13

Type mismatch
A string variable name is assigned a numeric
value or vice versa; a function that expects
a numeric argument is given a string argument
or vice versa.

Page F-3

os

14

Out of string space
String variables have caused BASIC to exceed
the amount of free memory remaining. BASIC
will allocate string space dynamically, until
it runs out of memory.

LS

15

String too long
An attempt is made to create
than 255 characters long.

a

string

more

ST

16

String formula too complex
A string expression is too long or too
complex.
The expression should be broken
into smaller expressions.

CN

17

Can~t continue
An attempt is made
that:

UF

18

to

continue

1.

has halted due to an error,

2.

has been modified
execution, or

3.

does not exist.

during

a

a

program

break

in

Undefined user function
A USR function is called before the function
definition (DEF statement) is given.
Extended and Disk Versions Only

19

20

No RESUME
An error trapping routine is
contains no RESUME statement.

entered

but

RESUME without error
A RESUME statement is encountered before
error trapping routine is entered.

an

21

Unprintable error
An error message is not available fur ~e
This is
which exists.
error
condition
usually caused by an ERROR with an undefined
error code.

22

Missing operand
An expression contains an
operand following it.

23

operator

with

no

Line buffer overflow
An attempt is made to input a line
too many characters.

that

has

Page F-4

26

29

30

FOR without NEXT
A FOR was encountered
NEXT.

without

WHILE without WEND
A WHILE statement does not
WEND.
WEND without WHILE
A WEND was encountered
WHILE.

have

without

a

matching

a-- matching

a

matching

Disk Errors
50

Field overflow
A FIELD statement is attempting to allocate
more bytes than were specified for the record
length of a random file.

51

Internal error
An internal malfunction has occurred in
BASIC-80.

52

Bad file number
A statement or command references a file with
a file number that is not OPEN or is out of
the range of file numbers specified
at
initialization.

53

File not found
A LOAD, KILL or OPEN statement references a
file that does not exist on the current disk.

54

Bad file mode
An attempt is made to use PUT, GET, or LOF
with a sequential file, to LOAD a random file
or to execute an OPEN with a file mode other
than I, 0, or R.

55

File already open
A sequential output mode OPEN is issued for a
file that is already open1
or a KILL is
given for a file that is open.

57

Disk I/O error
a
disk
I/O
An I/O error occurred on
operation.
It is a fatal error, i. e. , the
operating system cannot recover from the
error.

Disk

Page F-5

58

File already exists
The filename specified in a NAME statement is
identical to a filename already in use on the
disk.

61

Disk full
All disk storage space is in use.

62

Input past end
An INPUT statement is exeucted after all the
data in the file has been INPUT, or for a
null. (empty) file. To avoid this error, use
the EOF function to detect the end of file.

63

Bad record number
In a PUT or GET statement, the record number
is either greater than the maximum allowed
(32767) or equal to zero.

64

Bad file name
An illegal form is used for the filename with
LOAD, SAVE, KILL, or OPEN (e.g., a filename
with too many characters).

66

Direct statement in file
A direct statement is encountered
while
LOADing an ASCII-format file. The LOAD is
terminated.

67

Too many files
An attempt is made to create a new file
(using SAVE or OPEN) when all 255 directory
entries are full.

Page G-l

APPENDIX G
Mathematical Functions

Derived Functions
Functions that are not
calculated as follows.

intrinsic

to

BASIC-80

may

be

Function

BASIC-80 Equivalent

SECANT
COSECANT
COTANGENT
INVERSE SINE
INVERSE COSINE
INVERSE SECANT

SEC(X)=l/COS(X)
CSC(X)=l/SIN(X)
COT(X)=l/TAN(X)
ARCSIN(X)=ATN(X/SQR(-X*X+l»
ARCCOS(X)=-ATN (X/SQR(-X*X+l»+1.5708
ARCSEC(X)=ATN(X/SQR(X*X-l»
+SGN(SGN(X)-l) *1.5708
ARCCSC(X)=ATN(X/SQR(X*X-l»
+(SGN(X)-l) *1.5708
ARCCOT(X) =ATN(X) +1.5708
SINH(X)=(EXP(X)-EXP(-X»/2
COSH(X)=(EXP(X)+EXP(-X»/2·
TANH(X)=EXP(-X)/EXP(X)+EXP(-X»*2+1
SECH(X)=2/(EXP(X)+EXP(-X»
CSCH(X)=2/(EXP(X)-EXP(-X»
COTH(X)=EXP(-X)/(EXP(X)-EXP(-X»*2+1

INVERSE COSECANT
INVERSE COTANGENT
HYPERBOLIC SINE
HYPERBOLIC COSINE
HYPERBOLIC TANGENT
HYPERBOLIC SECANT
HYPERBOLIC COSECANT
HYPERBOLIC COTANGENT
INVERSE HYPERBOLIC
SINE
INVERSE HY~ERBOLIC
COSINE
INVERSE HYPERBOLIC
TANGENT
INVERSE HYPERBOLIC
SECANT
INVERSE HYPERBOLIC
COSECANT
INVERSE HYPERBOLIC
COTANGENT

ARCSINH(X)=LOG(X+SQR(X*X+1»
ARCCOSH(X)=LOG(X+SQR(X*X-1)
ARCTANH(X)=LOG«1+X)/(1-X»/2
ARCSECH(X)=LOG«SQR(-X*X+1)+1)/X)
ARCCSCH(X)=LOG«SGN(X)*SQR(X*X+1)+1)/X
ARCCOTH(X)=LOG«X+1)/(X-l»/2

Page H-l
APPENDIX H
ASCII Character Codes

ASCII
Code
000
001
002
003
004
005
006
007
008
009
010
011
012
013
014
015
016
017
018
019
020
021
022
023
024
025
026
027
028
029
030
031
032
033
034
035
036
037
038
039
040
041
042

Character
NUL
SOH
STX
ETX
EOT
ENQ
ACK
BEL
BS
HT
LF
VT
FF
CR
50
SI
DLE
DC1
DC2
DC3
DC4
NAK
SYN
ETB
CAN
EM

SUB
ESCAPE
FS
GS
R5

US
SPACE
!

n

t
$
%
&
~

(
)

*

ASCII
Code
043
044
045
046
047
048
049
050
051
052
053
054
055
056
057
058
059
060
061
062
063
064
065
066
067
068
069
070
071
072
073
074
075
076
077
078
079
080
081
082
083
084
085

Character

+

,

/·
0
1
2
3
4
5
6
7
8
9

·

·,·

<
=
>
?

@

A
B
C
D
E
F
G
H

I
J
K
L
M

N
0
P
Q
R
5
T

ASCII
Code
086
087
088
089
090
091
092
093
094
095
096
097
098
099
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127

Character
V
W
X

Y
Z
{

\

]

A

<
~

a
b
c
d

e
f
9
h
i
j
k
1
m
n
0

P

q
r
s
t
u
v

w
x
Y

z
{

}
DEL

U

ASCII codes are in decimal.
LF=Line Feed, FF=Form Feed, CR=Carriage Return, DEL=Rubout

Page I-I
INDEX

ABS

• •.

.

Addition •
ALL

.

..

• .

• • • • • • .

3-2

• • • • • • • . 1-10
.

• .

• • .

. 2-4, 2-9

Arctangent • • ••
• • • • 3-3
Array variables • • • • • • • 1-7,
Arrays • • • • • • • • • • • • 1-7,
Ase • • • • • • • • • • • • • 3-2
ASCII codes • • • • • • • • • 3-2,
ASCII format • • • • • • • • • 2-4,
Assembly language subroutines 2-3,
C-1
ATN
• • • 3-3

2-9, 2-18
2-7, 2-11, 2-24
3-4
2-49, 2-77
2-16, 2-59, 3-23 to 3-24,

.......

AUTO

.........

Boolean operators

• • 1-2, 2-2
• 1-12

CALL • • • • • • . . . . . . . 2-3, C-5
Carriage return . . . . . . . 1-3, 2-36, 2-41 to 2-42,
2-83 to 2-85
Cassette tape • • • • • • • • 2-7, 2-11
COBL • • • • ••
•• • • • 3-3
CHAIN • • • • • • • •
•• 2-4, 2-9
Character set • • • •
•• 1-3
CHR$ • • • • • • • • • • • • • 3-4
CINT • • • • • • • • • • • • • 3-4
CLEAR • • • • • • • • ••
2-6, A-l
CLOAO • • • • •
•• • • • 2-7
CLOAD* • • • • • . • • • • • • 2-7
CLOAD? • • • •
• • • • 2-7
CLOSE • • •
• • • •
• 2-8, B-3, B-8
Command level • • ••
•• 1-1
COMMON • • • • • • • • • • • • 2-4, 2-9
Concatenation • • • • • • • • 1-15
Constants
• • • • ••
1-4
CONT • • • • • • • • • • • • • 2-10, 2-41
Control characters • • • • • • 1-4.
Contro1-A • • • • • • • • • • 2-22
COS • • • • • • • • • • • • • 3-5
CP/M • • • • • • • • • • • • • 2-46, 2-49, 2-76 to 2-77,
B-1, 0";'1
CSAVE • • • • • • • • • • • • 2-11
CSAVE* • • • • • • • • • • • • 2-11
CSNG •
• • • •
• • 3-5
CVD
• ••
•• • • ••
3-6, B-8
CVI
• • • • • • • • • 3-6, B-8
CVS
• • • • • • • 3-6, B-8

Page I-2
2-12, 2-74
2-13
2-~6, 3-23
1-7, 2~15
1-7, 2-15
1-7, 2-15
1-7, 2-15
C-1.
1-2, 2-4, 2-17
2-18
1-1, 2-34, 2-54
1-10
• 1-5, 2-15, 2-60, 3-3, A-1,

·

DATA
DEF FN·.
DEF OSR
DEFDBL •
DEFINT
DEFSNG
•
DEFSTR
DEINT
DELETE
DIM
Direct mode
Division •
Double precision

··
·
·

•

•

·
•

·

·

EDIT
Edit mode
END

• •
• •

EOF
• .. •
•
ERASE
•
• •
ERL
ERR
•
ERROR
Error codes
•
Error messages
•
Error trapping •

3-6, B-3, B-5, D-4
2-24
•
•
2-25
•
•
2-25
2-26
• • •
1-16,
2-25 to 2-26
•
1-16
•
• •
• 2-25 to 2-26, 2-54, 2-75,
B-7
•
•
• 1-3, 2-19
3-7
•
• •
• 1-10 to 1-11
1-9
•
•

·

·

Escape
•
EXP
•
Exponentiation
Expressions
FIELD
FILES
FIX
FOR ••• NEXT

·•
•

2-28, B-8
D-3
3-7
• 2-29, A-1

·

•
•

·

•

·

FRCINT
FRE
Functions

•

•
•

GET

C-4, D-4
· C-1,
3-8
1-14, 2-13, 3-1

• • • • 2-28, 2-31, B-8, D-4

GIVABF •
GOSUB
GOTO

1-2, 2-19
1-4, 2-19
2-8, 2-10, 2-23, 2-3/

·

• 2-32
•

•

HEX$ •
Hexadecimal
IF ••• GOTO
IF ••• THEN
IF ••• T.HEN ••• ELSE

· C-1 to C-2

•

•
•

·

2-32 to 2-33

3-8
1-5, 3-8
2-34
2-25, 2-34
2-34

Indirect mode • • • • • • • • 1-1
INKEY$ •
. • • • • • • • • 3-9
INP

• .

INPUT

• .

.

.

.

.

• • •

INPUT$ •

.

Fage I-3

• • • . 3-9

• • • • • 2-10, 2-28, 2-36, A-2,
B-9
.

. . . .

INPUTt • • • • •
INPUTt • • • • •
INSTR • • • • •
INT • • • • • •
Integer •• • .
Inreaer division

•
•
•
•

•
•
•
•

•
•
•
•

•

.

.

• •
••
• •
• •
•

.

. 3-10

• . 8-.. 3
2-38
• • 3-11
• • 3-7, 3-12
•• 3-4, 3-7, 3-12
• • 1-10

Interrupts • • • • • • • • • • C-7
ISIS-II • • • • • • • • • • • 2-76
• • 2-39, B-2

KILL ••

LEFT$ • • • • •
• • • • • 3-12
LEN • • • • • • • • • • • • • 3-13
LET • • • • • • • • • • • • • 2-28, 2-40, B-9
Line feed

• • • • • • • • 1-2, 2-36, 2-41 to 2-42,
2-84 to 2-85
LINE INPUT
••••
• • 2-41
LINE INPUTt • • • • • • • • • B-3
LINE INPUTt • • •
•• • • 2-42
Line numbers • • • • • • • • • 1-1 to 1-2, 2-2, 2-73
Line printer • • • • • • • • • 2-45, 2-47, 2-83, 3-14,
A-2
Lines
• • • • • •
•• 1-1
LIST • • • • • • • • • • • • • 1-2, 2-43
LLIST • • • • • • • • • • • • 2-45
LOAD • • • • • • • • • • • • • 2-46, 2-77, B-1
LOC • • • • • •
• • • • • 3-13, B-3, B-5, B-8
LOF • • • • • • •
• • • • D-4
LOG • • • • • • •
• • • • 3-1,*
Logical operators • • • • • • 1-12
Loops • • ••
• • • • • • 2-29, 2-82
LPOS • • • • • • • • • • • • • 2-83, 3-14
LPRINT • • • • • • • • • • • • 2-47, 2-83
LPRINT USING
.••
• • 2-47
LSET • • • • • • • ••
•• 2-48, B-8

MAKINT
MBASIC

• • • • • • • C-1, C-4, D-4,
• • • • • • • D-1

MERGE • • • • • •
MID$ •
• • • •
MKD$ • • • • • • •
MKI$ • • • • • • •
MKS$ •
••• •
MOD operator • • •
Modulus arithmetic
Multiplication • •

•
•
•
.
•

•
•
•
•

• • 2-4, 2-49, B-2
• • 2-50, 3-15
• • • • 3-15, B-8
•• 3-15, B-8
• • • • 3-15, B-8
•• 1-11 .
1-11

. . . • 1-10

Page I-4
NAME • •

••

• • •

•

· 2-51
· 1-10
• 2-8, 2-52
NULL • • • • • • • • • •
• 2-53
Numeric constants . • • · • • 1-4
Numeric variables • • •
• 1-7
Negation . • . • • • • •
NEW
• • • . • •

OCT$ • • • ••
• • • • • • 3-16
Octal • • . .
. • • • 1-5" 3-16
ON ERROR GOTO
. •.
• 2-54
ON ••• GOSUB • • • • • ••
• 2-55
ON ••• GOTO • • • • • • ~ • • • 2-55
OPEN • . • •
• 2-8, 2-28, 2-56, B-3,
B-8
Operators
• 1-9, 1-11 to 1-13, 1-15

·..·...

OPTION BASE
• • • • • • • 2-57
OUT
• • • • . • • • • • • 2-58
Overflow • • • • • • • ••
1-11, 3-7, 3-22, A-1,
Overlay

• 2-4

2-53
·
·
·
·
·
·
·
·
2-59, 3-16
·
· · · · · · · · · · 2-59, 3-16
·
3-17
·· · · ·· ·· ·· ·· ·· · · · · ·· 2-83,
2-60, A-1
· · · · · ·· · · · · ·· ·· 2-62, A-2

Paper tape
PEEK
POKE
•
POS
PRINT
PRINT USING

PRINTi USING • •
PRINTi USING • •
PRINTi • • • • •
PRINTi USING .
PRINTi • • • • •
Protected files
PUT • • • • •

• • • • •
• •
•
• • • •
• •
• • • • •

• • B-5
• • B-3
• B-3
. • 2-66
• • 2-66
• 2-77, A-2, B-2
• • • • • • 2-28, 2-68, B-8

Random files •

• 2-28, 2-31, 2-39, 2-48,
2-56, 2-68, 3-13, 3-15,
B-7, D-4
Random numbers
• 2-69, 3-18
RANDOMIZE ••
• • . • 2-69, 3-18, A-1
READ • ••
••••
· • 2-70, 2-74
Relational operators
• . • 1-11
REM
• • ••
• • • • • • • 2-72
RE~UM
• • • • • • • • • • 2-4, 2-25, 2-73
RESET • • • • • • . • • • • • D-3
RESTORE • • •
• • • • 2-74
RESUME • • • • • • • • • • • • 2-75
RETURN • • • • • • • • • • • • 2-32
RIGHT$ • • • • •
• • • • • 3-17
RND • ••
.• •
• • • 2-69, 3-18, A-1
RSET •
•• • . • • ••
2-48, B-8
Rubout • • • • • • • • • • • • 1-3, 1-15, 2-20
RUN • • • • . • • • • • • • • 2-76 to 2-77, B-2

SAVE •

• • 2-46, 2-76 to 2-77, B-1

Page I-S

SBC • • • • • • • • •
Sequential files • • •

·· .. • • G-1
2-38 to 2-39, 2-42, 2-56,
2-66, 2-85, 3-6, 3-13,
B-3

SGN

•

•

•

S-IN

•

•

• • • • •

•

•

•

•

•

•

• •

Single precision •
SPACES •
• • • • •
SPC
SQR"

•
•

STOP.

•
•

•
•

•
•

•
•

•
•

•
•

•
•

•
•

·· .. .. •• 3-18
3-19
· . . . 1-5, 2-15, 2-60, 3-5, A-1
• • 3-19
• • • • 3-20
• • • • 3-20

· . . . . . . . · . . • 2-10, 2-23, 2-32, 2-78,

STR$ •
• • • • • • • • • • 3-21
String constants •
• • • • 1-4
String functions •
• • 3-6, 3-11 to 3-13, 3-15,
3-17, 3-21, 3-23
String operators • • • • • • • 1-15
Str ing space • • • • • • • • • 2-6, 3-8, A-1, B-9
String variables • • • • • • • 1-7, 2-15, 2-41 to 2-42
STRING$ • • • • •
•• • • 3-21
Subroutines • • • • • • • • • 2-3, 2-32, 2-55, C-1
Subscripts • • • • • • • • • • 1-7, 2-18, 2-57
Subtraction • • • • • • • • • 1-10
SWAP • • • • • • • • • • • • • 2-79

SYSTEM • • • • • • • • • • • • 0-4

·· .. .. .. .. .. .. .. . • •• •• •• 1-3
3-22
to 1-4
· .......
• • •
TROFF • • • • • • • • · . . • 2-80
TRON • • • • • • • • • · . . • 2-80

TAB

Tab

3-2~

TAN

OSR • • • • • • •
• • • • 2-16, 3-23, C-1
OSRLOC • • • • • • • · . . . . C-2
VAL
• • • • • • • • • • • • • 3-23
Variables
• • 1-6
VARPTR •• • • • • • • • • • • 3-24

·.·...

·· ·· · ·• •• ·• ·· •• • ·• •• 2-81
2-82
·
2-82
•
·
·
·
·
·
·
·
·
·
·
2-83, A-2
•
•
•
•
•
· · · ·• · • ·· · · ·· · 2-83, A-2
2-84
· · · •• ·• ·• ·• ·• ·• ·· •• B-3
· · · • • • · · · • · 2-85

WAIT •
•
WEND •
• •
WHILE
WIDTH
•
WIDTH LPRINT •
WRITE •
•
WRITE# • •
•
WRITE#
•

